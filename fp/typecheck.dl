.table stringLit
.table intLit
.table letExpr
.table lambda
.table lambdaParam
.table funcCall
.table funcArg
.table var
.table builtin

expr{id: I} :-
  stringLit{id: I} |
  intLit{id: I} |
  var{id: I} |
  letExpr{id: I} |
  funcCall{id: I} |
  lambda{id: I}.

type{id: I, type: T} :-
  type_s{id: I, type: T} |
  type_i{id: I, type: T} |
  type_lambda{id: I, type: T} |
  type_fc{id: I, type: T} |
  type_let{id: I, type: T} |
  type_var{id: I, type: T}.

type_s{id: I, type: "string"} :-
  stringLit{id: I}.
type_i{id: I, type: "int"} :-
  intLit{id: I}.
type_fc{id: I, type: T} :-
  funcCall{id: I, name: M} &
  scope_item{id: I, name: M, type: tapp{from: F, to: T}} &
  funcArg{callExprID: I, argExprID: AI} &
  type{id: AI, type: F}.
type_let{id: I, type: T} :-
  letExpr{id: I, bodyID: BID} &
  type{id: BID, type: T}.
type_var{id: I, type: T} :-
  var{id: I, name: N} &
  scope_item{id: I, name: N, type: T}.
# TODO: get this to work for multiple parameters...
type_lambda{id: I, type: tapp{from: F, to: R}} :-
  lambda{id: I, retType: R, body: B} &
  lambdaParam{lambdaID: I, ty: F} &
  type{id: B, type: R}.

scope_item{id: I, name: N, type: T} :-
  expr{id: I} & builtin{name: N, type: T} |
  scope_let{id: I, name: N, type: T} |
  scope_lambda{id: I, name: N, type: T} |
  parent_expr{id: I, parentID: P} & scope_item{id: P, name: N, type: T}.

# this recursion is not working for some reason
scope_let{id: I, name: N, type: T} :-
  letExpr{bodyID: I, varName: N, bindingID: B} &
  type{id: B, type: T}.
scope_lambda{id: I, name: N, type: T} :-
  lambda{body: I, id: LID} &
  lambdaParam{lambdaID: LID, name: N, ty: T}.

parent_expr{id: I, parentID: P} :-
  letExpr{bodyID: I, id: P} |
  funcArg{argExprID: I, callExprID: P}.
