type{id: I, type: T} :-
  type_s{id: I, type: T} |
  type_i{id: I, type: T} |
  type_lambda{id: I, type: T} |
  type_fc{id: I, type: T}.

type_s{id: I, type: "string"} :-
  stringLit{id: I}.
type_i{id: I, type: "int"} :-
  intLit{id: I}.
type_fc{id: I, type: T} :-
  scope_item{id: I, name: N, type: tapp{to: T}} &
  funcCall{id: I, name: N}.
# TODO: get this to work for multiple parameters...
type_lambda{id: I, type: tapp{from: F, to: R}} :-
  lambda{id: I, retType: R} &
  lambdaParam{lambdaID: I, ty: F}.

scope_item{id: I, name: N, type: T} :-
  scope_let{id: I, name: N, type: T} |
  scope_lambda{id: I, name: N, type: T}.

scope_let{id: I, name: N, type: T} :-
  letExpr{bodyID: I, varName: N, bindingID: B} &
  type{id: B, type: T}.
scope_lambda{id: I, name: N, type: T} :-
  lambda{body: I, id: LID} &
  lambdaParam{lambdaID: LID, name: N, ty: T}.
