.table root_expr
.table string_lit
.table int_lit
.table let_expr
.table lambda
.table lambda_param
.table func_call
.table func_arg
.table var
.table placeholder
.table builtin

expr{id: I} :-
  string_lit{id: I} |
  int_lit{id: I} |
  var{id: I} |
  let_expr{id: I} |
  func_call{id: I} |
  lambda{id: I}.

type{id: I, type: T} :-
  type_s{id: I, type: T} |
  type_i{id: I, type: T} |
  type_lambda{id: I, type: T} |
  type_fc{id: I, type: T} |
  type_let{id: I, type: T} |
  type_var{id: I, type: T}.

type_s{id: I, type: "string"} :-
  string_lit{id: I}.
type_i{id: I, type: "int"} :-
  int_lit{id: I}.
type_fc{id: I, type: T} :-
  func_call{id: I, funcID: FID, argID: AID} &
  type{id: FID, type: tapp{from: F, to: T}} &
  type{id: AID, type: F}.
type_let{id: I, type: T} :-
  let_expr{id: I, bodyID: BID} &
  type{id: BID, type: T}.
type_var{id: I, type: T} :-
  var{id: I, name: N} &
  scope_item{id: I, name: N, type: T}.
# TODO: get this to work for multiple parameters...
type_lambda{id: I, type: tapp{from: F, to: R}} :-
  lambda{id: I, retType: R, body: B} &
  lambda_param{lambdaID: I, ty: F} &
  type{id: B, type: R}.

scope_item{id: I, name: N, type: T} :-
  root_expr{id: I} & builtin{name: N, type: T} |
  scope_let{id: I, name: N, type: T} |
  scope_lambda{id: I, name: N, type: T} |
  parent_expr{id: I, parentID: P} & scope_item{id: P, name: N, type: T}.

# this recursion is not working for some reason
scope_let{id: I, name: N, type: T} :-
  let_expr{bodyID: I, varName: N, bindingID: B} &
  type{id: B, type: T}.
scope_lambda{id: I, name: N, type: T} :-
  lambda{body: I, id: LID} &
  lambda_param{lambdaID: LID, name: N, ty: T}.

parent_expr{id: I, parentID: P} :-
  let_expr{bodyID: I, id: P} |
  let_expr{bindingID: I, id: P} |
  func_call{argID: I, id: P} |
  func_call{funcID: I, id: P} |
  lambda{body: I, id: P}.

# type-directed autocomplete suggestions
suggestion{id: I, name: N, type: TF} :-
  placeholder{id: I} &
  func_call{argID: I, funcID: F} &
  type{id: F, type: tapp{from: TF, to: TT}} &
  scope_item{id: I, type: TF, name: N}.
