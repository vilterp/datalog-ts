.table root_expr
.table string_lit
.table int_lit
.table let_expr
.table lambda
.table lambda_param
.table func_call
.table var
.table placeholder
.table builtin

expr{id: I, location: S} :-
  string_lit{id: I, location: S} |
  int_lit{id: I, location: S} |
  var{id: I, location: S} |
  let_expr{id: I, location: S} |
  func_call{id: I, location: S} |
  lambda{id: I, location: S} |
  placeholder{id: I, location: S}.

type{id: I, type: T} :-
  type_s{id: I, type: T} |
  type_i{id: I, type: T} |
  type_lambda{id: I, type: T} |
  type_fc{id: I, type: T} |
  type_let{id: I, type: T} |
  type_var{id: I, type: T}.

type_s{id: I, type: "string"} :-
  string_lit{id: I}.
type_i{id: I, type: "int"} :-
  int_lit{id: I}.
type_fc{id: I, type: T} :-
  func_call{id: I, funcID: FID, argID: AID} &
  type{id: FID, type: tapp{from: F, to: T}} &
  type{id: AID, type: F}.
type_let{id: I, type: T} :-
  let_expr{id: I, bodyID: BID} &
  type{id: BID, type: T}.
type_var{id: I, type: T} :-
  var{id: I, name: N} &
  scope_item{id: I, name: N, type: T}.
# TODO: get this to work for multiple parameters...
type_lambda{id: I, type: tapp{from: F, to: R}} :-
  lambda{id: I, retType: R, body: B} &
  lambda_param{lambdaID: I, ty: F} &
  type{id: B, type: R}.

scope_item{id: I, name: N, type: T, location: L} :-
  scope_builtin{id: I, name: N, type: T, location: L} |
  scope_let{id: I, name: N, type: T, location: L} |
  scope_lambda{id: I, name: N, type: T, location: L} |
  parent_scope{id: I, parentID: P} & scope_item{id: P, name: N, type: T, location: L}.

scope_builtin{id: I, name: N, type: T, location: "builtin"} :-
  root_expr{id: I} & builtin{name: N, type: T}.
scope_let{id: I, name: N, type: T, location: L} :-
  let_expr{bodyID: I, varName: N, bindingID: B, varLoc: L} &
  type{id: B, type: T}.
scope_lambda{id: I, name: N, type: T, location: L} :-
  lambda{body: I, id: LID} &
  lambda_param{lambdaID: LID, name: N, ty: T, location: L}.

parent_scope{id: I, parentID: P} :-
  let_expr{bodyID: I, id: P} |
  let_expr{bindingID: I, id: P} |
  func_call{argID: I, id: P} |
  func_call{funcID: I, id: P} |
  lambda{body: I, id: P}.

# type-directed autocomplete suggestions
suggestion{id: I, name: N, type: T} :-
  suggestion_func_arg{id: I, name: N, type: T} |
  suggestion_func{id: I, name: N, type: T}.

suggestion_func_arg{id: I, name: N, type: TF} :-
  placeholder{id: I} &
  func_call{argID: I, funcID: F} &
  type{id: F, type: tapp{from: TF, to: TT}} &
  scope_item{id: I, type: TF, name: N}.

suggestion_func{id: I, name: N, type: tapp{from: TF, to: TT}} :-
  placeholder{id: I} &
  expected_type{id: I, type: TT} &
  scope_item{id: I, name: N, type: tapp{from: TF, to: TT}}.

expected_type{id: I, type: T} :-
  lambda{retType: T, body: I} |
  lambda{retType: T, body: B} & let_expr{id: B, bodyID: I}.

usage{definitionLoc: DL, usageLoc: UL, name: N} :-
  var{id: I, name: N, location: UL} &
  scope_item{id: I, name: N, location: DL}.

# cursor-dependent rules
current_suggestion{id: I, name: N, type: T} :-
  cursor{idx: Idx} &
  placeholder{id: I, location: span{from: pos{idx: Idx}}} &
  suggestion{id: I, name: N, type: T}.

current_scope{id: I, name: N, type: T} :-
  cursor{idx: Idx} &
  expr{id: I, location: span{from: pos{idx: Idx}}} &
  scope_item{id: I, name: N, type: T}.

current_type{id: I, type: T} :-
  cursor{idx: Idx} &
  expr{id: I, location: span{from: pos{idx: Idx}}} &
  type{id: I, type: T}.

current_usage{name: N, usageLoc: ULL} :-
  cursor{idx: Idx} &
  usage{definitionLoc: span{from: pos{idx: Idx}}, name: N, usageLoc: ULL}.

current_definition{name: N, definitionLoc: DLL} :-
  cursor{idx: Idx} &
  usage{definitionLoc: DLL, name: N, usageLoc: span{from: pos{idx: Idx}}}.
