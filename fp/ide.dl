# type-directed autocomplete suggestions
suggestion{id: I, name: N, type: T, typeMatch: M} :-
  suggestion_var{id: I, name: N, type: T, typeMatch: M} |
  suggestion_func{id: I, name: N, type: T, typeMatch: M} |
  suggestion_scope{id: I, name: N, type: T, typeMatch: M}.

suggestion_var{id: I, name: N, type: T, typeMatch: true} :-
  placeholder{id: I} &
  expected_type{id: I, type: T} &
  scope_item{id: I, type: T, name: N}.
suggestion_func{id: I, name: N, type: tapp{from: TF, to: TT}, typeMatch: true} :-
  placeholder{id: I} &
  expected_type{id: I, type: TT} &
  scope_item{id: I, name: N, type: tapp{from: TF, to: TT}}.
suggestion_scope{id: I, name: N, type: T, typeMatch: false} :-
  placeholder{id: I} &
  scope_item{id: I, name: N, type: T}.

expected_type{id: I, type: T} :-
  lambda{retType: T, body: I} |
  let_expr{id: L, bodyID: I} & expected_type{id: L, type: T} |
  func_call{argID: I, funcID: F} & type{id: F, type: tapp{from: T}} |
  expected_type_binding{id: I, type: T}.
expected_type_binding{id: I, type: T} :-
  let_expr{varLoc: VL, bindingID: I} &
  usage{definitionLoc: VL, usageLoc: UL} &
  expr{id: UI, location: UL} &
  expected_type{id: UI, type: T}.

usage{definitionLoc: DL, usageLoc: UL, name: N} :-
  var{id: I, name: N, location: UL} &
  scope_item{id: I, name: N, location: DL}.

# cursor-dependent rules
current_placeholder{id: I, span: span{from: FIdx, to: TIdx}} :-
  placeholder{id: I, location: span{from: FIdx, to: TIdx}} &
  cursor{idx: CIdx} &
  FIdx <= CIdx & CIdx <= TIdx.

current_suggestion{id: I, name: N, type: T, typeMatch: M} :-
  current_placeholder{id: I} &
  suggestion{id: I, name: N, type: T, typeMatch: M}.

current_scope{id: I, name: N, type: T} :-
  cursor{idx: Idx} &
  expr{id: I, location: span{from: Idx}} &
  scope_item{id: I, name: N, type: T}.

current_type{id: I, type: T} :-
  cursor{idx: Idx} &
  expr{id: I, location: span{from: Idx}} &
  type{id: I, type: T}.

current_usage{name: N, usageLoc: ULL} :-
  cursor{idx: Idx} &
  usage{definitionLoc: span{from: Idx}, name: N, usageLoc: ULL}.

current_definition{name: N, definitionLoc: DLL} :-
  cursor{idx: Idx} &
  usage{definitionLoc: DLL, name: N, usageLoc: span{from: Idx}}.

defn_for_cursor{defnLoc: DL} :-
  cursor{idx: CIdx} &
  usage{definitionLoc: DL, usageLoc: span{from: FIdx, to: TIdx}} &
  FIdx <= CIdx & CIdx <= TIdx.
