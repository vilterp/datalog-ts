// generated by parserlib; do not edit.
import {
  textForSpan,
  childByName,
  childrenByName,
  RuleTree,
  extractRuleTree,
} from "../../parserlib/ruleTree";
import { Span, Grammar } from "../../parserlib/types";
import * as parserlib from "../../parserlib/parser";
export type GrammarAlpha = {
  type: "Alpha";
  text: string;
  width: number;
};
export type GrammarAlphaNum = GrammarAlpha | GrammarNum;
export type GrammarAnyChar = {
  type: "AnyChar";
  text: string;
  width: number;
};
export type GrammarCaptureName = {
  type: "CaptureName";
  text: string;
  width: number;
  ident: GrammarIdent;
};
export type GrammarCharRange = {
  type: "CharRange";
  text: string;
  width: number;
  from: GrammarAlphaNum;
  to: GrammarAlphaNum;
};
export type GrammarCharRule =
  | GrammarCharRange
  | GrammarNotChar
  | GrammarSingleChar
  | GrammarAnyChar;
export type GrammarChoice = {
  type: "Choice";
  text: string;
  width: number;
  rule: GrammarRule[];
};
export type GrammarCommaSpace = {
  type: "CommaSpace";
  text: string;
  width: number;
};
export type GrammarComment = {
  type: "Comment";
  text: string;
  width: number;
  commentChar: GrammarCommentChar[];
};
export type GrammarCommentChar = {
  type: "CommentChar";
  text: string;
  width: number;
};
export type GrammarIdent = {
  type: "Ident";
  text: string;
  width: number;
  alpha: GrammarAlpha[];
};
export type GrammarMain = {
  type: "Main";
  text: string;
  width: number;
  ruleDefn: GrammarRuleDefn[];
  comment: GrammarComment[];
};
export type GrammarNotChar = {
  type: "NotChar";
  text: string;
  width: number;
  charRule: GrammarCharRule;
};
export type GrammarNum = {
  type: "Num";
  text: string;
  width: number;
};
export type GrammarPlaceholder = {
  type: "Placeholder";
  text: string;
  width: number;
};
export type GrammarRef = {
  type: "Ref";
  text: string;
  width: number;
  captureName: GrammarCaptureName | null;
  ruleName: GrammarRuleName;
};
export type GrammarRepSep = {
  type: "RepSep";
  text: string;
  width: number;
  repSepKW: GrammarRepSepKW;
  rep: GrammarRule;
  commaSpace: GrammarCommaSpace;
  sep: GrammarRule;
};
export type GrammarRepSepKW = {
  type: "RepSepKW";
  text: string;
  width: number;
};
export type GrammarRule =
  | GrammarSeq
  | GrammarChoice
  | GrammarRef
  | GrammarText
  | GrammarCharRule
  | GrammarRepSep
  | GrammarPlaceholder;
export type GrammarRuleDefn = {
  type: "RuleDefn";
  text: string;
  width: number;
  ident: GrammarIdent;
  rule: GrammarRule;
};
export type GrammarRuleName = {
  type: "RuleName";
  text: string;
  width: number;
  ident: GrammarIdent;
};
export type GrammarSeq = {
  type: "Seq";
  text: string;
  width: number;
  rule: GrammarRule[];
};
export type GrammarSingleChar = {
  type: "SingleChar";
  text: string;
  width: number;
};
export type GrammarStringChar = {
  type: "StringChar";
  text: string;
  width: number;
};
export type GrammarText = {
  type: "Text";
  text: string;
  width: number;
  stringChar: GrammarStringChar[];
};
export type GrammarWs = {
  type: "Ws";
  text: string;
  width: number;
};
export function parseAlpha(input: string): GrammarAlpha {
  const traceTree = parserlib.parse(GRAMMAR, "alpha", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlpha(input, 0, ruleTree);
}
export function parseAlphaNum(input: string): GrammarAlphaNum {
  const traceTree = parserlib.parse(GRAMMAR, "alphaNum", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlphaNum(input, 0, ruleTree);
}
export function parseAnyChar(input: string): GrammarAnyChar {
  const traceTree = parserlib.parse(GRAMMAR, "anyChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAnyChar(input, 0, ruleTree);
}
export function parseCaptureName(input: string): GrammarCaptureName {
  const traceTree = parserlib.parse(GRAMMAR, "captureName", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCaptureName(input, 0, ruleTree);
}
export function parseCharRange(input: string): GrammarCharRange {
  const traceTree = parserlib.parse(GRAMMAR, "charRange", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCharRange(input, 0, ruleTree);
}
export function parseCharRule(input: string): GrammarCharRule {
  const traceTree = parserlib.parse(GRAMMAR, "charRule", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCharRule(input, 0, ruleTree);
}
export function parseChoice(input: string): GrammarChoice {
  const traceTree = parserlib.parse(GRAMMAR, "choice", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractChoice(input, 0, ruleTree);
}
export function parseCommaSpace(input: string): GrammarCommaSpace {
  const traceTree = parserlib.parse(GRAMMAR, "commaSpace", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaSpace(input, 0, ruleTree);
}
export function parseComment(input: string): GrammarComment {
  const traceTree = parserlib.parse(GRAMMAR, "comment", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractComment(input, 0, ruleTree);
}
export function parseCommentChar(input: string): GrammarCommentChar {
  const traceTree = parserlib.parse(GRAMMAR, "commentChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommentChar(input, 0, ruleTree);
}
export function parseIdent(input: string): GrammarIdent {
  const traceTree = parserlib.parse(GRAMMAR, "ident", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractIdent(input, 0, ruleTree);
}
export function parseMain(input: string): GrammarMain {
  const traceTree = parserlib.parse(GRAMMAR, "main", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractMain(input, 0, ruleTree);
}
export function parseNotChar(input: string): GrammarNotChar {
  const traceTree = parserlib.parse(GRAMMAR, "notChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNotChar(input, 0, ruleTree);
}
export function parseNum(input: string): GrammarNum {
  const traceTree = parserlib.parse(GRAMMAR, "num", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNum(input, 0, ruleTree);
}
export function parsePlaceholder(input: string): GrammarPlaceholder {
  const traceTree = parserlib.parse(GRAMMAR, "placeholder", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPlaceholder(input, 0, ruleTree);
}
export function parseRef(input: string): GrammarRef {
  const traceTree = parserlib.parse(GRAMMAR, "ref", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRef(input, 0, ruleTree);
}
export function parseRepSep(input: string): GrammarRepSep {
  const traceTree = parserlib.parse(GRAMMAR, "repSep", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRepSep(input, 0, ruleTree);
}
export function parseRepSepKW(input: string): GrammarRepSepKW {
  const traceTree = parserlib.parse(GRAMMAR, "repSepKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRepSepKW(input, 0, ruleTree);
}
export function parseRule(input: string): GrammarRule {
  const traceTree = parserlib.parse(GRAMMAR, "rule", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRule(input, 0, ruleTree);
}
export function parseRuleDefn(input: string): GrammarRuleDefn {
  const traceTree = parserlib.parse(GRAMMAR, "ruleDefn", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRuleDefn(input, 0, ruleTree);
}
export function parseRuleName(input: string): GrammarRuleName {
  const traceTree = parserlib.parse(GRAMMAR, "ruleName", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRuleName(input, 0, ruleTree);
}
export function parseSeq(input: string): GrammarSeq {
  const traceTree = parserlib.parse(GRAMMAR, "seq", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSeq(input, 0, ruleTree);
}
export function parseSingleChar(input: string): GrammarSingleChar {
  const traceTree = parserlib.parse(GRAMMAR, "singleChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSingleChar(input, 0, ruleTree);
}
export function parseStringChar(input: string): GrammarStringChar {
  const traceTree = parserlib.parse(GRAMMAR, "stringChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractStringChar(input, 0, ruleTree);
}
export function parseText(input: string): GrammarText {
  const traceTree = parserlib.parse(GRAMMAR, "text", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractText(input, 0, ruleTree);
}
function extractAlpha(
  input: string,
  pos: number,
  node: RuleTree
): GrammarAlpha {
  return {
    type: "Alpha",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractAlphaNum(
  input: string,
  pos: number,
  node: RuleTree
): GrammarAlphaNum {
  const child = node.children[0];
  switch (child.name) {
    case "alpha": {
      return extractAlpha(input, pos, child);
    }
    case "num": {
      return extractNum(input, pos, child);
    }
  }
}
function extractAnyChar(
  input: string,
  pos: number,
  node: RuleTree
): GrammarAnyChar {
  return {
    type: "AnyChar",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractCaptureName(
  input: string,
  pos: number,
  node: RuleTree
): GrammarCaptureName {
  return {
    type: "CaptureName",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    ident: extractIdent(input, pos, childByName(node, "ident", null)),
  };
}
function extractCharRange(
  input: string,
  pos: number,
  node: RuleTree
): GrammarCharRange {
  return {
    type: "CharRange",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    from: extractAlphaNum(input, pos, childByName(node, "alphaNum", "from")),
    to: extractAlphaNum(input, pos, childByName(node, "alphaNum", "to")),
  };
}
function extractCharRule(
  input: string,
  pos: number,
  node: RuleTree
): GrammarCharRule {
  const child = node.children[0];
  switch (child.name) {
    case "charRange": {
      return extractCharRange(input, pos, child);
    }
    case "notChar": {
      return extractNotChar(input, pos, child);
    }
    case "singleChar": {
      return extractSingleChar(input, pos, child);
    }
    case "anyChar": {
      return extractAnyChar(input, pos, child);
    }
  }
}
function extractChoice(
  input: string,
  pos: number,
  node: RuleTree
): GrammarChoice {
  return {
    type: "Choice",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    rule: childrenByName(node, "rule").map((child) =>
      extractRule(input, pos, child)
    ),
  };
}
function extractCommaSpace(
  input: string,
  pos: number,
  node: RuleTree
): GrammarCommaSpace {
  return {
    type: "CommaSpace",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractComment(
  input: string,
  pos: number,
  node: RuleTree
): GrammarComment {
  return {
    type: "Comment",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    commentChar: childrenByName(node, "commentChar").map((child) =>
      extractCommentChar(input, pos, child)
    ),
  };
}
function extractCommentChar(
  input: string,
  pos: number,
  node: RuleTree
): GrammarCommentChar {
  return {
    type: "CommentChar",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractIdent(
  input: string,
  pos: number,
  node: RuleTree
): GrammarIdent {
  return {
    type: "Ident",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    alpha: childrenByName(node, "alpha").map((child) =>
      extractAlpha(input, pos, child)
    ),
  };
}
function extractMain(input: string, pos: number, node: RuleTree): GrammarMain {
  return {
    type: "Main",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    ruleDefn: childrenByName(node, "ruleDefn").map((child) =>
      extractRuleDefn(input, pos, child)
    ),
    comment: childrenByName(node, "comment").map((child) =>
      extractComment(input, pos, child)
    ),
  };
}
function extractNotChar(
  input: string,
  pos: number,
  node: RuleTree
): GrammarNotChar {
  return {
    type: "NotChar",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    charRule: extractCharRule(input, pos, childByName(node, "charRule", null)),
  };
}
function extractNum(input: string, pos: number, node: RuleTree): GrammarNum {
  return {
    type: "Num",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractPlaceholder(
  input: string,
  pos: number,
  node: RuleTree
): GrammarPlaceholder {
  return {
    type: "Placeholder",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractRef(input: string, pos: number, node: RuleTree): GrammarRef {
  return {
    type: "Ref",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    captureName: childByName(node, "captureName", null)
      ? extractCaptureName(input, pos, childByName(node, "captureName", null))
      : null,
    ruleName: extractRuleName(input, pos, childByName(node, "ruleName", null)),
  };
}
function extractRepSep(
  input: string,
  pos: number,
  node: RuleTree
): GrammarRepSep {
  return {
    type: "RepSep",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    repSepKW: extractRepSepKW(input, pos, childByName(node, "repSepKW", null)),
    rep: extractRule(input, pos, childByName(node, "rule", "rep")),
    commaSpace: extractCommaSpace(
      input,
      pos,
      childByName(node, "commaSpace", null)
    ),
    sep: extractRule(input, pos, childByName(node, "rule", "sep")),
  };
}
function extractRepSepKW(
  input: string,
  pos: number,
  node: RuleTree
): GrammarRepSepKW {
  return {
    type: "RepSepKW",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractRule(input: string, pos: number, node: RuleTree): GrammarRule {
  const child = node.children[0];
  switch (child.name) {
    case "seq": {
      return extractSeq(input, pos, child);
    }
    case "choice": {
      return extractChoice(input, pos, child);
    }
    case "ref": {
      return extractRef(input, pos, child);
    }
    case "text": {
      return extractText(input, pos, child);
    }
    case "charRule": {
      return extractCharRule(input, pos, child);
    }
    case "repSep": {
      return extractRepSep(input, pos, child);
    }
    case "placeholder": {
      return extractPlaceholder(input, pos, child);
    }
  }
}
function extractRuleDefn(
  input: string,
  pos: number,
  node: RuleTree
): GrammarRuleDefn {
  return {
    type: "RuleDefn",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    ident: extractIdent(input, pos, childByName(node, "ident", null)),
    rule: extractRule(input, pos, childByName(node, "rule", null)),
  };
}
function extractRuleName(
  input: string,
  pos: number,
  node: RuleTree
): GrammarRuleName {
  return {
    type: "RuleName",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    ident: extractIdent(input, pos, childByName(node, "ident", null)),
  };
}
function extractSeq(input: string, pos: number, node: RuleTree): GrammarSeq {
  return {
    type: "Seq",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    rule: childrenByName(node, "rule").map((child) =>
      extractRule(input, pos, child)
    ),
  };
}
function extractSingleChar(
  input: string,
  pos: number,
  node: RuleTree
): GrammarSingleChar {
  return {
    type: "SingleChar",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractStringChar(
  input: string,
  pos: number,
  node: RuleTree
): GrammarStringChar {
  return {
    type: "StringChar",
    text: input.substring(pos, pos + node.width),
    width: node.width,
  };
}
function extractText(input: string, pos: number, node: RuleTree): GrammarText {
  return {
    type: "Text",
    text: input.substring(pos, pos + node.width),
    width: node.width,
    stringChar: childrenByName(node, "stringChar").map((child) =>
      extractStringChar(input, pos, child)
    ),
  };
}
const GRAMMAR: Grammar = {
  main: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Ref",
          captureName: null,
          rule: "ruleDefn",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "comment",
        },
      ],
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "ws",
    },
  },
  comment: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "#",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "commentChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  ruleDefn: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ":-",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "rule",
      },
      {
        type: "Text",
        value: ".",
      },
    ],
  },
  rule: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "seq",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "choice",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ref",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "text",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "charRule",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "repSep",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "placeholder",
      },
    ],
  },
  seq: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "[",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "rule",
        },
        sep: {
          type: "Sequence",
          items: [
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
            {
              type: "Text",
              value: ",",
            },
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
          ],
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "]",
      },
    ],
  },
  choice: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "(",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "rule",
        },
        sep: {
          type: "Sequence",
          items: [
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
            {
              type: "Text",
              value: "|",
            },
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
          ],
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  ref: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Sequence",
            items: [
              {
                type: "Ref",
                captureName: null,
                rule: "captureName",
              },
              {
                type: "Text",
                value: ":",
              },
            ],
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ruleName",
      },
    ],
  },
  captureName: {
    type: "Ref",
    captureName: null,
    rule: "ident",
  },
  ruleName: {
    type: "Ref",
    captureName: null,
    rule: "ident",
  },
  text: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: '"',
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "stringChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
      {
        type: "Text",
        value: '"',
      },
    ],
  },
  repSep: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "repSepKW",
      },
      {
        type: "Text",
        value: "(",
      },
      {
        type: "Ref",
        captureName: "rep",
        rule: "rule",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "commaSpace",
      },
      {
        type: "Ref",
        captureName: "sep",
        rule: "rule",
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  repSepKW: {
    type: "Text",
    value: "repSep",
  },
  charRule: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "charRange",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "notChar",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "singleChar",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "anyChar",
      },
    ],
  },
  charRange: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "[",
      },
      {
        type: "Ref",
        captureName: "from",
        rule: "alphaNum",
      },
      {
        type: "Text",
        value: "-",
      },
      {
        type: "Ref",
        captureName: "to",
        rule: "alphaNum",
      },
      {
        type: "Text",
        value: "]",
      },
    ],
  },
  notChar: {
    type: "Sequence",
    items: [
      {
        type: "Char",
        rule: {
          type: "Literal",
          value: "^",
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "charRule",
      },
    ],
  },
  singleChar: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "'",
      },
      {
        type: "Choice",
        choices: [
          {
            type: "Sequence",
            items: [
              {
                type: "Char",
                rule: {
                  type: "Literal",
                  value: "\\",
                },
              },
              {
                type: "Char",
                rule: {
                  type: "Literal",
                  value: "n",
                },
              },
            ],
          },
          {
            type: "Sequence",
            items: [
              {
                type: "Char",
                rule: {
                  type: "Literal",
                  value: "\\",
                },
              },
              {
                type: "Char",
                rule: {
                  type: "Literal",
                  value: "\\",
                },
              },
            ],
          },
          {
            type: "Char",
            rule: {
              type: "AnyChar",
            },
          },
        ],
      },
      {
        type: "Text",
        value: "'",
      },
    ],
  },
  anyChar: {
    type: "Text",
    value: ".",
  },
  ident: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "alpha",
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  ws: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Text",
          value: " ",
        },
        {
          type: "Text",
          value: "\n",
        },
      ],
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  commaSpace: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
  placeholder: {
    type: "Text",
    value: "???",
  },
  alphaNum: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "num",
      },
    ],
  },
  alpha: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "a",
          to: "z",
        },
      },
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
    ],
  },
  num: {
    type: "Char",
    rule: {
      type: "Range",
      from: "0",
      to: "9",
    },
  },
  stringChar: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Not",
          rule: {
            type: "Literal",
            value: '"',
          },
        },
      },
      {
        type: "Sequence",
        items: [
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: "\\",
            },
          },
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: '"',
            },
          },
        ],
      },
    ],
  },
  commentChar: {
    type: "Char",
    rule: {
      type: "Not",
      rule: {
        type: "Literal",
        value: "\n",
      },
    },
  },
};
