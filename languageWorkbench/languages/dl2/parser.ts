// generated by parserlib; do not edit.
import {
  textForSpan,
  childByName,
  childrenByName,
  RuleTree,
  extractRuleTree,
} from "../../parserlib/ruleTree";
import { Span, Grammar } from "../../parserlib/types";
import * as parserlib from "../../parserlib/parser";
export type DL2Abstraction = DL2PointwiseAbstraction | DL2PointFreeAbstraction;
export type DL2Alpha = {
  type: "Alpha";
  text: string;
  span: Span;
};
export type DL2AlphaNum = DL2Alpha | DL2Num;
export type DL2Application = {
  type: "Application";
  text: string;
  span: Span;
  expr: DL2RelExpr | null;
  parenExpr: DL2RelExpr | null;
  scalarExpr: DL2ScalarExpr[];
  commaSpace: DL2CommaSpace[];
};
export type DL2Assertion = {
  type: "Assertion";
  text: string;
  span: Span;
  ident: DL2Ident;
  scalarExpr: DL2ScalarExpr[];
  commaSpace: DL2CommaSpace[];
};
export type DL2CommaSpace = {
  type: "CommaSpace";
  text: string;
  span: Span;
};
export type DL2Conjunct = DL2Negation | DL2Assertion;
export type DL2Decl = {
  type: "Decl";
  text: string;
  span: Span;
  ident: DL2Ident;
  relExpr: DL2RelExpr;
};
export type DL2Disjunct = {
  type: "Disjunct";
  text: string;
  span: Span;
  conjunct: DL2Conjunct[];
};
export type DL2Disjunction = {
  type: "Disjunction";
  text: string;
  span: Span;
  disjunct: DL2Disjunct[];
};
export type DL2File = {
  type: "File";
  text: string;
  span: Span;
  decl: DL2Decl[];
};
export type DL2Formula = {
  type: "Formula";
  text: string;
  span: Span;
  disjunction: DL2Disjunction;
};
export type DL2Ident = {
  type: "Ident";
  text: string;
  span: Span;
  alpha: DL2Alpha;
  alphaNum: DL2AlphaNum[];
};
export type DL2IntLit = {
  type: "IntLit";
  text: string;
  span: Span;
  first: DL2Num;
  num: DL2Num[];
};
export type DL2Main = {
  type: "Main";
  text: string;
  span: Span;
  file: DL2File;
};
export type DL2Negation = {
  type: "Negation";
  text: string;
  span: Span;
  assertion: DL2Assertion;
};
export type DL2Num = {
  type: "Num";
  text: string;
  span: Span;
};
export type DL2Placeholder = {
  type: "Placeholder";
  text: string;
  span: Span;
};
export type DL2PointFreeAbstraction = {
  type: "PointFreeAbstraction";
  text: string;
  span: Span;
  ident: DL2Ident[];
  commaSpace: DL2CommaSpace[];
  scalarExpr: DL2ScalarExpr;
};
export type DL2PointwiseAbstraction = {
  type: "PointwiseAbstraction";
  text: string;
  span: Span;
  ident: DL2Ident[];
  commaSpace: DL2CommaSpace[];
  formula: DL2Formula;
};
export type DL2RelExpr = DL2Ident | DL2RelationLiteral | DL2Abstraction;
export type DL2RelationLiteral = {
  type: "RelationLiteral";
  text: string;
  span: Span;
  tuple: DL2Tuple[];
  commaSpace: DL2CommaSpace[];
};
export type DL2ScalarExpr = DL2Term | DL2Application;
export type DL2ScalarLiteral = DL2IntLit | DL2StringLit;
export type DL2StringChar = {
  type: "StringChar";
  text: string;
  span: Span;
};
export type DL2StringLit = {
  type: "StringLit";
  text: string;
  span: Span;
  stringChar: DL2StringChar[];
};
export type DL2Term = DL2Var | DL2ScalarLiteral;
export type DL2Tuple = {
  type: "Tuple";
  text: string;
  span: Span;
  scalarLiteral: DL2ScalarLiteral[];
  commaSpace: DL2CommaSpace[];
};
export type DL2Var = {
  type: "Var";
  text: string;
  span: Span;
  alphaNum: DL2AlphaNum[];
};
export type DL2Ws = {
  type: "Ws";
  text: string;
  span: Span;
};
export function parseAbstraction(input: string): DL2Abstraction {
  const traceTree = parserlib.parse(GRAMMAR, "abstraction", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAbstraction(input, ruleTree);
}
export function parseAlpha(input: string): DL2Alpha {
  const traceTree = parserlib.parse(GRAMMAR, "alpha", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlpha(input, ruleTree);
}
export function parseAlphaNum(input: string): DL2AlphaNum {
  const traceTree = parserlib.parse(GRAMMAR, "alphaNum", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlphaNum(input, ruleTree);
}
export function parseApplication(input: string): DL2Application {
  const traceTree = parserlib.parse(GRAMMAR, "application", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractApplication(input, ruleTree);
}
export function parseAssertion(input: string): DL2Assertion {
  const traceTree = parserlib.parse(GRAMMAR, "assertion", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAssertion(input, ruleTree);
}
export function parseCommaSpace(input: string): DL2CommaSpace {
  const traceTree = parserlib.parse(GRAMMAR, "commaSpace", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaSpace(input, ruleTree);
}
export function parseConjunct(input: string): DL2Conjunct {
  const traceTree = parserlib.parse(GRAMMAR, "conjunct", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConjunct(input, ruleTree);
}
export function parseDecl(input: string): DL2Decl {
  const traceTree = parserlib.parse(GRAMMAR, "decl", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractDecl(input, ruleTree);
}
export function parseDisjunct(input: string): DL2Disjunct {
  const traceTree = parserlib.parse(GRAMMAR, "disjunct", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractDisjunct(input, ruleTree);
}
export function parseDisjunction(input: string): DL2Disjunction {
  const traceTree = parserlib.parse(GRAMMAR, "disjunction", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractDisjunction(input, ruleTree);
}
export function parseFile(input: string): DL2File {
  const traceTree = parserlib.parse(GRAMMAR, "file", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractFile(input, ruleTree);
}
export function parseFormula(input: string): DL2Formula {
  const traceTree = parserlib.parse(GRAMMAR, "formula", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractFormula(input, ruleTree);
}
export function parseIdent(input: string): DL2Ident {
  const traceTree = parserlib.parse(GRAMMAR, "ident", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractIdent(input, ruleTree);
}
export function parseIntLit(input: string): DL2IntLit {
  const traceTree = parserlib.parse(GRAMMAR, "intLit", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractIntLit(input, ruleTree);
}
export function parseMain(input: string): DL2Main {
  const traceTree = parserlib.parse(GRAMMAR, "main", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractMain(input, ruleTree);
}
export function parseNegation(input: string): DL2Negation {
  const traceTree = parserlib.parse(GRAMMAR, "negation", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNegation(input, ruleTree);
}
export function parseNum(input: string): DL2Num {
  const traceTree = parserlib.parse(GRAMMAR, "num", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNum(input, ruleTree);
}
export function parsePlaceholder(input: string): DL2Placeholder {
  const traceTree = parserlib.parse(GRAMMAR, "placeholder", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPlaceholder(input, ruleTree);
}
export function parsePointFreeAbstraction(
  input: string
): DL2PointFreeAbstraction {
  const traceTree = parserlib.parse(GRAMMAR, "pointFreeAbstraction", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPointFreeAbstraction(input, ruleTree);
}
export function parsePointwiseAbstraction(
  input: string
): DL2PointwiseAbstraction {
  const traceTree = parserlib.parse(GRAMMAR, "pointwiseAbstraction", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPointwiseAbstraction(input, ruleTree);
}
export function parseRelExpr(input: string): DL2RelExpr {
  const traceTree = parserlib.parse(GRAMMAR, "relExpr", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRelExpr(input, ruleTree);
}
export function parseRelationLiteral(input: string): DL2RelationLiteral {
  const traceTree = parserlib.parse(GRAMMAR, "relationLiteral", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRelationLiteral(input, ruleTree);
}
export function parseScalarExpr(input: string): DL2ScalarExpr {
  const traceTree = parserlib.parse(GRAMMAR, "scalarExpr", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarExpr(input, ruleTree);
}
export function parseScalarLiteral(input: string): DL2ScalarLiteral {
  const traceTree = parserlib.parse(GRAMMAR, "scalarLiteral", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarLiteral(input, ruleTree);
}
export function parseStringChar(input: string): DL2StringChar {
  const traceTree = parserlib.parse(GRAMMAR, "stringChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractStringChar(input, ruleTree);
}
export function parseStringLit(input: string): DL2StringLit {
  const traceTree = parserlib.parse(GRAMMAR, "stringLit", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractStringLit(input, ruleTree);
}
export function parseTerm(input: string): DL2Term {
  const traceTree = parserlib.parse(GRAMMAR, "term", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractTerm(input, ruleTree);
}
export function parseTuple(input: string): DL2Tuple {
  const traceTree = parserlib.parse(GRAMMAR, "tuple", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractTuple(input, ruleTree);
}
export function parseVar(input: string): DL2Var {
  const traceTree = parserlib.parse(GRAMMAR, "var", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVar(input, ruleTree);
}
function extractAbstraction(input: string, node: RuleTree): DL2Abstraction {
  const child = node.children[0];
  switch (child.name) {
    case "pointwiseAbstraction": {
      return extractPointwiseAbstraction(input, child);
    }
    case "pointFreeAbstraction": {
      return extractPointFreeAbstraction(input, child);
    }
  }
}
function extractAlpha(input: string, node: RuleTree): DL2Alpha {
  return {
    type: "Alpha",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractAlphaNum(input: string, node: RuleTree): DL2AlphaNum {
  const child = node.children[0];
  switch (child.name) {
    case "alpha": {
      return extractAlpha(input, child);
    }
    case "num": {
      return extractNum(input, child);
    }
  }
}
function extractApplication(input: string, node: RuleTree): DL2Application {
  return {
    type: "Application",
    text: textForSpan(input, node.span),
    span: node.span,
    expr: childByName(node, "relExpr", "expr")
      ? extractRelExpr(input, childByName(node, "relExpr", "expr"))
      : null,
    parenExpr: childByName(node, "relExpr", "parenExpr")
      ? extractRelExpr(input, childByName(node, "relExpr", "parenExpr"))
      : null,
    scalarExpr: childrenByName(node, "scalarExpr").map((child) =>
      extractScalarExpr(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractAssertion(input: string, node: RuleTree): DL2Assertion {
  return {
    type: "Assertion",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    scalarExpr: childrenByName(node, "scalarExpr").map((child) =>
      extractScalarExpr(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractCommaSpace(input: string, node: RuleTree): DL2CommaSpace {
  return {
    type: "CommaSpace",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractConjunct(input: string, node: RuleTree): DL2Conjunct {
  const child = node.children[0];
  switch (child.name) {
    case "negation": {
      return extractNegation(input, child);
    }
    case "assertion": {
      return extractAssertion(input, child);
    }
  }
}
function extractDecl(input: string, node: RuleTree): DL2Decl {
  return {
    type: "Decl",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    relExpr: extractRelExpr(input, childByName(node, "relExpr", null)),
  };
}
function extractDisjunct(input: string, node: RuleTree): DL2Disjunct {
  return {
    type: "Disjunct",
    text: textForSpan(input, node.span),
    span: node.span,
    conjunct: childrenByName(node, "conjunct").map((child) =>
      extractConjunct(input, child)
    ),
  };
}
function extractDisjunction(input: string, node: RuleTree): DL2Disjunction {
  return {
    type: "Disjunction",
    text: textForSpan(input, node.span),
    span: node.span,
    disjunct: childrenByName(node, "disjunct").map((child) =>
      extractDisjunct(input, child)
    ),
  };
}
function extractFile(input: string, node: RuleTree): DL2File {
  return {
    type: "File",
    text: textForSpan(input, node.span),
    span: node.span,
    decl: childrenByName(node, "decl").map((child) =>
      extractDecl(input, child)
    ),
  };
}
function extractFormula(input: string, node: RuleTree): DL2Formula {
  return {
    type: "Formula",
    text: textForSpan(input, node.span),
    span: node.span,
    disjunction: extractDisjunction(
      input,
      childByName(node, "disjunction", null)
    ),
  };
}
function extractIdent(input: string, node: RuleTree): DL2Ident {
  return {
    type: "Ident",
    text: textForSpan(input, node.span),
    span: node.span,
    alpha: extractAlpha(input, childByName(node, "alpha", null)),
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractIntLit(input: string, node: RuleTree): DL2IntLit {
  return {
    type: "IntLit",
    text: textForSpan(input, node.span),
    span: node.span,
    first: extractNum(input, childByName(node, "num", "first")),
    num: childrenByName(node, "num").map((child) => extractNum(input, child)),
  };
}
function extractMain(input: string, node: RuleTree): DL2Main {
  return {
    type: "Main",
    text: textForSpan(input, node.span),
    span: node.span,
    file: extractFile(input, childByName(node, "file", null)),
  };
}
function extractNegation(input: string, node: RuleTree): DL2Negation {
  return {
    type: "Negation",
    text: textForSpan(input, node.span),
    span: node.span,
    assertion: extractAssertion(input, childByName(node, "assertion", null)),
  };
}
function extractNum(input: string, node: RuleTree): DL2Num {
  return {
    type: "Num",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractPlaceholder(input: string, node: RuleTree): DL2Placeholder {
  return {
    type: "Placeholder",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractPointFreeAbstraction(
  input: string,
  node: RuleTree
): DL2PointFreeAbstraction {
  return {
    type: "PointFreeAbstraction",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: childrenByName(node, "ident").map((child) =>
      extractIdent(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
    scalarExpr: extractScalarExpr(input, childByName(node, "scalarExpr", null)),
  };
}
function extractPointwiseAbstraction(
  input: string,
  node: RuleTree
): DL2PointwiseAbstraction {
  return {
    type: "PointwiseAbstraction",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: childrenByName(node, "ident").map((child) =>
      extractIdent(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
    formula: extractFormula(input, childByName(node, "formula", null)),
  };
}
function extractRelExpr(input: string, node: RuleTree): DL2RelExpr {
  const child = node.children[0];
  switch (child.name) {
    case "ident": {
      return extractIdent(input, child);
    }
    case "relationLiteral": {
      return extractRelationLiteral(input, child);
    }
    case "abstraction": {
      return extractAbstraction(input, child);
    }
  }
}
function extractRelationLiteral(
  input: string,
  node: RuleTree
): DL2RelationLiteral {
  return {
    type: "RelationLiteral",
    text: textForSpan(input, node.span),
    span: node.span,
    tuple: childrenByName(node, "tuple").map((child) =>
      extractTuple(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractScalarExpr(input: string, node: RuleTree): DL2ScalarExpr {
  const child = node.children[0];
  switch (child.name) {
    case "term": {
      return extractTerm(input, child);
    }
    case "application": {
      return extractApplication(input, child);
    }
  }
}
function extractScalarLiteral(input: string, node: RuleTree): DL2ScalarLiteral {
  const child = node.children[0];
  switch (child.name) {
    case "intLit": {
      return extractIntLit(input, child);
    }
    case "stringLit": {
      return extractStringLit(input, child);
    }
  }
}
function extractStringChar(input: string, node: RuleTree): DL2StringChar {
  return {
    type: "StringChar",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractStringLit(input: string, node: RuleTree): DL2StringLit {
  return {
    type: "StringLit",
    text: textForSpan(input, node.span),
    span: node.span,
    stringChar: childrenByName(node, "stringChar").map((child) =>
      extractStringChar(input, child)
    ),
  };
}
function extractTerm(input: string, node: RuleTree): DL2Term {
  const child = node.children[0];
  switch (child.name) {
    case "var": {
      return extractVar(input, child);
    }
    case "scalarLiteral": {
      return extractScalarLiteral(input, child);
    }
  }
}
function extractTuple(input: string, node: RuleTree): DL2Tuple {
  return {
    type: "Tuple",
    text: textForSpan(input, node.span),
    span: node.span,
    scalarLiteral: childrenByName(node, "scalarLiteral").map((child) =>
      extractScalarLiteral(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractVar(input: string, node: RuleTree): DL2Var {
  return {
    type: "Var",
    text: textForSpan(input, node.span),
    span: node.span,
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
const GRAMMAR: Grammar = {
  main: {
    type: "Ref",
    captureName: null,
    rule: "file",
  },
  file: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "decl",
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "ws",
    },
  },
  decl: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "=",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "relExpr",
      },
      {
        type: "Text",
        value: ".",
      },
    ],
  },
  formula: {
    type: "Ref",
    captureName: null,
    rule: "disjunction",
  },
  disjunction: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "disjunct",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "or",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  disjunct: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "conjunct",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "and",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  conjunct: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "negation",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "assertion",
      },
    ],
  },
  negation: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "!",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "assertion",
      },
    ],
  },
  assertion: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Text",
        value: "(",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "scalarExpr",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  relExpr: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "relationLiteral",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "abstraction",
      },
    ],
  },
  relationLiteral: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "tuple",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  tuple: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "(",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "scalarLiteral",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  abstraction: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "pointwiseAbstraction",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "pointFreeAbstraction",
      },
    ],
  },
  pointwiseAbstraction: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "(",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "ident",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Text",
        value: ")",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ":-",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "formula",
      },
    ],
  },
  pointFreeAbstraction: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "[",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "ident",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Text",
        value: "]",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ":-",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "scalarExpr",
      },
    ],
  },
  scalarExpr: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "term",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "application",
      },
    ],
  },
  application: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Ref",
            captureName: "expr",
            rule: "relExpr",
          },
          {
            type: "Sequence",
            items: [
              {
                type: "Text",
                value: "(",
              },
              {
                type: "Ref",
                captureName: "parenExpr",
                rule: "relExpr",
              },
              {
                type: "Text",
                value: ")",
              },
            ],
          },
        ],
      },
      {
        type: "Text",
        value: "[",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "scalarExpr",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaSpace",
        },
      },
      {
        type: "Text",
        value: "]",
      },
    ],
  },
  term: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "var",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "scalarLiteral",
      },
    ],
  },
  scalarLiteral: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "intLit",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "stringLit",
      },
    ],
  },
  intLit: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Text",
            value: "-",
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: "first",
        rule: "num",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "num",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  ident: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
            {
              type: "Text",
              value: ".",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  stringLit: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: '"',
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "stringChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
      {
        type: "Text",
        value: '"',
      },
    ],
  },
  var: {
    type: "Sequence",
    items: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Char",
              rule: {
                type: "Range",
                from: "A",
                to: "Z",
              },
            },
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  stringChar: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Not",
          rule: {
            type: "Literal",
            value: '"',
          },
        },
      },
      {
        type: "Sequence",
        items: [
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: "\\",
            },
          },
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: '"',
            },
          },
        ],
      },
    ],
  },
  alpha: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "a",
          to: "z",
        },
      },
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "Text",
        value: "_",
      },
    ],
  },
  num: {
    type: "Char",
    rule: {
      type: "Range",
      from: "0",
      to: "9",
    },
  },
  alphaNum: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "num",
      },
    ],
  },
  ws: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Text",
          value: " ",
        },
        {
          type: "Text",
          value: "\n",
        },
      ],
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  placeholder: {
    type: "Text",
    value: "???",
  },
  commaSpace: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
};
