// generated by parserlib; do not edit.
import {
  textForSpan,
  childByName,
  childrenByName,
  RuleTree,
  extractRuleTree,
} from "../../parserlib/ruleTree";
import { Span, Grammar, ParseError } from "../../parserlib/types";
import * as parserlib from "../../parserlib/parser";
export type SQLAlpha = {
  type: "Alpha";
  text: string;
  span: Span;
};
export type SQLAlphaNum = SQLAlpha | SQLNum;
export type SQLColSpec = {
  type: "ColSpec";
  text: string;
  span: Span;
  columnName: SQLColumnName;
  _type: SQLType;
  refClause: SQLRefClause | null;
};
export type SQLColumnName = SQLIdent | SQLPlaceholder;
export type SQLCommaWS = {
  type: "CommaWS";
  text: string;
  span: Span;
};
export type SQLCreateKW = {
  type: "CreateKW";
  text: string;
  span: Span;
};
export type SQLCreateTableStmt = {
  type: "CreateTableStmt";
  text: string;
  span: Span;
  createKW: SQLCreateKW;
  tableKW: SQLTableKW;
  tableName: SQLTableName;
  colSpec: SQLColSpec[];
  commaWS: SQLCommaWS[];
};
export type SQLFromKW = {
  type: "FromKW";
  text: string;
  span: Span;
};
export type SQLIdent = {
  type: "Ident";
  text: string;
  span: Span;
  alpha: SQLAlpha;
  alphaNum: SQLAlphaNum[];
};
export type SQLMain = {
  type: "Main";
  text: string;
  span: Span;
  statementSemicolon: SQLStatementSemicolon[];
};
export type SQLNum = {
  type: "Num";
  text: string;
  span: Span;
};
export type SQLPlaceholder = {
  type: "Placeholder";
  text: string;
  span: Span;
};
export type SQLRefClause = {
  type: "RefClause";
  text: string;
  span: Span;
  refKW: SQLRefKW;
  tableName: SQLTableName;
  columnName: SQLColumnName;
};
export type SQLRefKW = {
  type: "RefKW";
  text: string;
  span: Span;
};
export type SQLSelectKW = {
  type: "SelectKW";
  text: string;
  span: Span;
};
export type SQLSelectStmt = {
  type: "SelectStmt";
  text: string;
  span: Span;
  selectKW: SQLSelectKW;
  selection: SQLSelection;
  fromKW: SQLFromKW;
  tableName: SQLTableName;
};
export type SQLSelection = {
  type: "Selection";
  text: string;
  span: Span;
  columnName: SQLColumnName[];
  commaWS: SQLCommaWS[];
};
export type SQLStatement = SQLSelectStmt | SQLCreateTableStmt;
export type SQLStatementSemicolon = {
  type: "StatementSemicolon";
  text: string;
  span: Span;
  statement: SQLStatement;
};
export type SQLString = {
  type: "String";
  text: string;
  span: Span;
  stringChar: SQLStringChar[];
};
export type SQLStringChar = {
  type: "StringChar";
  text: string;
  span: Span;
};
export type SQLTableKW = {
  type: "TableKW";
  text: string;
  span: Span;
};
export type SQLTableName = SQLIdent | SQLPlaceholder;
export type SQLType = {
  type: "Type";
  text: string;
  span: Span;
};
export type SQLWs = {
  type: "Ws";
  text: string;
  span: Span;
};
export function parseAlpha(input: string): [SQLAlpha, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "alpha", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractAlpha(input, ruleTree);
  return [extracted, errors];
}
export function parseAlphaNum(input: string): [SQLAlphaNum, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "alphaNum", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractAlphaNum(input, ruleTree);
  return [extracted, errors];
}
export function parseColSpec(input: string): [SQLColSpec, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "colSpec", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractColSpec(input, ruleTree);
  return [extracted, errors];
}
export function parseColumnName(input: string): [SQLColumnName, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "columnName", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractColumnName(input, ruleTree);
  return [extracted, errors];
}
export function parseCommaWS(input: string): [SQLCommaWS, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "commaWS", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractCommaWS(input, ruleTree);
  return [extracted, errors];
}
export function parseCreateKW(input: string): [SQLCreateKW, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "createKW", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractCreateKW(input, ruleTree);
  return [extracted, errors];
}
export function parseCreateTableStmt(
  input: string
): [SQLCreateTableStmt, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "createTableStmt", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractCreateTableStmt(input, ruleTree);
  return [extracted, errors];
}
export function parseFromKW(input: string): [SQLFromKW, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "fromKW", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractFromKW(input, ruleTree);
  return [extracted, errors];
}
export function parseIdent(input: string): [SQLIdent, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "ident", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractIdent(input, ruleTree);
  return [extracted, errors];
}
export function parseMain(input: string): [SQLMain, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "main", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractMain(input, ruleTree);
  return [extracted, errors];
}
export function parseNum(input: string): [SQLNum, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "num", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractNum(input, ruleTree);
  return [extracted, errors];
}
export function parsePlaceholder(
  input: string
): [SQLPlaceholder, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "placeholder", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractPlaceholder(input, ruleTree);
  return [extracted, errors];
}
export function parseRefClause(input: string): [SQLRefClause, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "refClause", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractRefClause(input, ruleTree);
  return [extracted, errors];
}
export function parseRefKW(input: string): [SQLRefKW, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "refKW", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractRefKW(input, ruleTree);
  return [extracted, errors];
}
export function parseSelectKW(input: string): [SQLSelectKW, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "selectKW", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractSelectKW(input, ruleTree);
  return [extracted, errors];
}
export function parseSelectStmt(input: string): [SQLSelectStmt, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "selectStmt", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractSelectStmt(input, ruleTree);
  return [extracted, errors];
}
export function parseSelection(input: string): [SQLSelection, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "selection", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractSelection(input, ruleTree);
  return [extracted, errors];
}
export function parseStatement(input: string): [SQLStatement, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "statement", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractStatement(input, ruleTree);
  return [extracted, errors];
}
export function parseStatementSemicolon(
  input: string
): [SQLStatementSemicolon, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "statementSemicolon", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractStatementSemicolon(input, ruleTree);
  return [extracted, errors];
}
export function parseString(input: string): [SQLString, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "string", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractString(input, ruleTree);
  return [extracted, errors];
}
export function parseStringChar(input: string): [SQLStringChar, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "stringChar", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractStringChar(input, ruleTree);
  return [extracted, errors];
}
export function parseTableKW(input: string): [SQLTableKW, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "tableKW", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractTableKW(input, ruleTree);
  return [extracted, errors];
}
export function parseTableName(input: string): [SQLTableName, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "tableName", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractTableName(input, ruleTree);
  return [extracted, errors];
}
export function parseType(input: string): [SQLType, ParseError[]] {
  const traceTree = parserlib.parse(GRAMMAR, "type", input);
  const [ruleTree, errors] = extractRuleTree(traceTree);
  const extracted = extractType(input, ruleTree);
  return [extracted, errors];
}
function extractAlpha(input: string, node: RuleTree): SQLAlpha {
  return {
    type: "Alpha",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractAlphaNum(input: string, node: RuleTree): SQLAlphaNum {
  const child = node.children[0];
  switch (child.name) {
    case "alpha": {
      return extractAlpha(input, child);
    }
    case "num": {
      return extractNum(input, child);
    }
  }
}
function extractColSpec(input: string, node: RuleTree): SQLColSpec {
  return {
    type: "ColSpec",
    text: textForSpan(input, node.span),
    span: node.span,
    columnName: extractColumnName(input, childByName(node, "columnName", null)),
    _type: extractType(input, childByName(node, "type", null)),
    refClause: childByName(node, "refClause", null)
      ? extractRefClause(input, childByName(node, "refClause", null))
      : null,
  };
}
function extractColumnName(input: string, node: RuleTree): SQLColumnName {
  const child = node.children[0];
  switch (child.name) {
    case "ident": {
      return extractIdent(input, child);
    }
    case "placeholder": {
      return extractPlaceholder(input, child);
    }
  }
}
function extractCommaWS(input: string, node: RuleTree): SQLCommaWS {
  return {
    type: "CommaWS",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractCreateKW(input: string, node: RuleTree): SQLCreateKW {
  return {
    type: "CreateKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractCreateTableStmt(
  input: string,
  node: RuleTree
): SQLCreateTableStmt {
  return {
    type: "CreateTableStmt",
    text: textForSpan(input, node.span),
    span: node.span,
    createKW: extractCreateKW(input, childByName(node, "createKW", null)),
    tableKW: extractTableKW(input, childByName(node, "tableKW", null)),
    tableName: extractTableName(input, childByName(node, "tableName", null)),
    colSpec: childrenByName(node, "colSpec").map((child) =>
      extractColSpec(input, child)
    ),
    commaWS: childrenByName(node, "commaWS").map((child) =>
      extractCommaWS(input, child)
    ),
  };
}
function extractFromKW(input: string, node: RuleTree): SQLFromKW {
  return {
    type: "FromKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractIdent(input: string, node: RuleTree): SQLIdent {
  return {
    type: "Ident",
    text: textForSpan(input, node.span),
    span: node.span,
    alpha: extractAlpha(input, childByName(node, "alpha", null)),
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractMain(input: string, node: RuleTree): SQLMain {
  return {
    type: "Main",
    text: textForSpan(input, node.span),
    span: node.span,
    statementSemicolon: childrenByName(node, "statementSemicolon").map(
      (child) => extractStatementSemicolon(input, child)
    ),
  };
}
function extractNum(input: string, node: RuleTree): SQLNum {
  return {
    type: "Num",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractPlaceholder(input: string, node: RuleTree): SQLPlaceholder {
  return {
    type: "Placeholder",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractRefClause(input: string, node: RuleTree): SQLRefClause {
  return {
    type: "RefClause",
    text: textForSpan(input, node.span),
    span: node.span,
    refKW: extractRefKW(input, childByName(node, "refKW", null)),
    tableName: extractTableName(input, childByName(node, "tableName", null)),
    columnName: extractColumnName(input, childByName(node, "columnName", null)),
  };
}
function extractRefKW(input: string, node: RuleTree): SQLRefKW {
  return {
    type: "RefKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractSelectKW(input: string, node: RuleTree): SQLSelectKW {
  return {
    type: "SelectKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractSelectStmt(input: string, node: RuleTree): SQLSelectStmt {
  return {
    type: "SelectStmt",
    text: textForSpan(input, node.span),
    span: node.span,
    selectKW: extractSelectKW(input, childByName(node, "selectKW", null)),
    selection: extractSelection(input, childByName(node, "selection", null)),
    fromKW: extractFromKW(input, childByName(node, "fromKW", null)),
    tableName: extractTableName(input, childByName(node, "tableName", null)),
  };
}
function extractSelection(input: string, node: RuleTree): SQLSelection {
  return {
    type: "Selection",
    text: textForSpan(input, node.span),
    span: node.span,
    columnName: childrenByName(node, "columnName").map((child) =>
      extractColumnName(input, child)
    ),
    commaWS: childrenByName(node, "commaWS").map((child) =>
      extractCommaWS(input, child)
    ),
  };
}
function extractStatement(input: string, node: RuleTree): SQLStatement {
  const child = node.children[0];
  switch (child.name) {
    case "selectStmt": {
      return extractSelectStmt(input, child);
    }
    case "createTableStmt": {
      return extractCreateTableStmt(input, child);
    }
  }
}
function extractStatementSemicolon(
  input: string,
  node: RuleTree
): SQLStatementSemicolon {
  return {
    type: "StatementSemicolon",
    text: textForSpan(input, node.span),
    span: node.span,
    statement: extractStatement(input, childByName(node, "statement", null)),
  };
}
function extractString(input: string, node: RuleTree): SQLString {
  return {
    type: "String",
    text: textForSpan(input, node.span),
    span: node.span,
    stringChar: childrenByName(node, "stringChar").map((child) =>
      extractStringChar(input, child)
    ),
  };
}
function extractStringChar(input: string, node: RuleTree): SQLStringChar {
  return {
    type: "StringChar",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractTableKW(input: string, node: RuleTree): SQLTableKW {
  return {
    type: "TableKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractTableName(input: string, node: RuleTree): SQLTableName {
  const child = node.children[0];
  switch (child.name) {
    case "ident": {
      return extractIdent(input, child);
    }
    case "placeholder": {
      return extractPlaceholder(input, child);
    }
  }
}
function extractType(input: string, node: RuleTree): SQLType {
  return {
    type: "Type",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
export const GRAMMAR: Grammar = {
  main: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "statementSemicolon",
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "ws",
    },
  },
  statementSemicolon: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "statement",
      },
      {
        type: "Text",
        value: ";",
      },
    ],
  },
  statement: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "selectStmt",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "createTableStmt",
      },
    ],
  },
  selectStmt: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "selectKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "selection",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "fromKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "tableName",
      },
    ],
  },
  selection: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "columnName",
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "commaWS",
    },
  },
  createTableStmt: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "createKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "tableKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "tableName",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "(",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "colSpec",
        },
        sep: {
          type: "Ref",
          captureName: null,
          rule: "commaWS",
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  colSpec: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "columnName",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "type",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Choice",
        choices: [
          {
            type: "Ref",
            captureName: null,
            rule: "refClause",
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
    ],
  },
  refClause: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "refKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "tableName",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "(",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "columnName",
      },
      {
        type: "Text",
        value: ")",
      },
    ],
  },
  type: {
    type: "Choice",
    choices: [
      {
        type: "Text",
        value: "INT",
      },
      {
        type: "Text",
        value: "TEXT",
      },
    ],
  },
  columnName: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "placeholder",
      },
    ],
  },
  tableName: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "placeholder",
      },
    ],
  },
  createKW: {
    type: "Text",
    value: "CREATE",
  },
  tableKW: {
    type: "Text",
    value: "TABLE",
  },
  selectKW: {
    type: "Text",
    value: "SELECT",
  },
  fromKW: {
    type: "Text",
    value: "FROM",
  },
  refKW: {
    type: "Text",
    value: "REFERENCES",
  },
  ident: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
            {
              type: "Text",
              value: ".",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  string: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: '"',
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "stringChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
      {
        type: "Text",
        value: '"',
      },
    ],
  },
  stringChar: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Not",
          rule: {
            type: "Literal",
            value: '"',
          },
        },
      },
      {
        type: "Sequence",
        items: [
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: "\\",
            },
          },
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: '"',
            },
          },
        ],
      },
    ],
  },
  alpha: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "a",
          to: "z",
        },
      },
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "Text",
        value: "_",
      },
    ],
  },
  num: {
    type: "Char",
    rule: {
      type: "Range",
      from: "0",
      to: "9",
    },
  },
  alphaNum: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "num",
      },
    ],
  },
  ws: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Text",
          value: " ",
        },
        {
          type: "Text",
          value: "\n",
        },
      ],
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  commaWS: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
  placeholder: {
    type: "Text",
    value: "???",
  },
};
