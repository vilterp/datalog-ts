scope.Scope{id: RuleID, label: N} :-
  ast.rule{id: RuleID} &
  ast.record{id: RecordID, parentID: RuleID} &
  ast.ident{parentID: RecordID, text: N}.

scope.Defn{scopeID: I, span: S, name: N, kind: K} :-
  scope.defnRule{scopeID: I, span: S, name: N, kind: K} |
  scope.defnVar{scopeID: I, name: N, span: S, kind: K} |
  scope.defnTable{scopeID: I, name: N, span: S, kind: K} |
  scope.defnAttr{scopeID: I, name: N, span: S, kind: K}.
scope.defnRule{scopeID: global{}, span: S, name: N, kind: "relation"} :-
  scope.rule{span: S, name: N}.
# TODO: recurse into records as values
scope.defnVar{scopeID: RuleID, name: N, span: S, kind: "var"} :-
  ast.rule{id: RuleID} &
  ast.record{id: RecordID, parentID: RuleID} &
  ast.keyValue{id: KeyValueID, parentID: RecordID} &
  ast.term{id: ValueTermID, parentID: KeyValueID} &
  ast.var{span: S, text: N, parentID: ValueTermID}.
scope.defnTable{scopeID: global{}, name: N, span: S, kind: "relation"} :-
  ast.tableDecl{id: DeclID} &
  ast.ident{parentID: DeclID, span: S, text: N}.
scope.defnAttr{scopeID: RuleName, name: N, span: S, kind: "attr"} :-
  tc.ruleAttr{rule: RuleName, attr: N, span: S}.

scope.Var{scopeID: I, name: N, span: S, kind: K} :-
  scope.varRuleInvocation{scopeID: I, name: N, span: S, kind: K} |
  scope.varTerm{scopeID: I, name: N, span: S, kind: K} |
  scope.varAttr{scopeID: I, name: N, span: S, kind: K}.
scope.varRuleInvocation{scopeID: global{}, name: N, span: S, kind: "relation"} :-
  ast.rule{id: RuleID} &
  ast.disjunct{id: DisjunctID, parentID: RuleID} &
  ast.conjunct{id: ConjunctID, parentID: DisjunctID} &
  ast.record{id: RecordID, parentID: ConjunctID} &
  ast.ident{parentID: RecordID, text: N, span: S}.
# TODO: bin exprs
scope.varTerm{scopeID: RuleID, name: N, span: S, kind: "var"} :-
  ast.rule{id: RuleID} &
  ast.disjunct{id: DisjunctID, parentID: RuleID} &
  ast.conjunct{id: ConjunctID, parentID: DisjunctID} &
  ast.record{id: RecordID, parentID: ConjunctID} &
  ast.keyValue{id: KeyValueID, parentID: RecordID} &
  ast.term{id: ValueTermID, parentID: KeyValueID} &
  ast.var{parentID: ValueTermID, text: N, span: S}.
scope.varAttr{scopeID: Relation, nodeID: I, name: N, span: S, kind: "attr"} :-
  ast.conjunct{id: Conjunct} &
  ast.record{id: Rec, parentID: Conjunct} &
  ast.ident{parentID: Rec, text: Relation} &
  ast.keyValue{id: KV, parentID: Rec} &
  ast.ident{id: I, parentID: KV, text: N, span: S}.

scope.Placeholder{scopeID: I, span: S, kind: K} :-
  scope.placeholderVar{scopeID: I, span: S, kind: K} |
  scope.placeholderRule{scopeID: I, span: S, kind: K} |
  scope.placeholderAttr{scopeID: I, span: S, kind: K}.
scope.placeholderVar{scopeID: RuleID, span: S, kind: "var"} :-
  ast.rule{id: RuleID} &
  ast.disjunct{id: DisjunctID, parentID: RuleID} &
  ast.conjunct{id: ConjunctID, parentID: DisjunctID} &
  ast.record{id: RecordID, parentID: ConjunctID} &
  ast.keyValue{id: KeyValueID, parentID: RecordID} &
  ast.term{id: ValueTermID, parentID: KeyValueID} &
  ast.placeholder{parentID: ValueTermID, span: S}.
scope.placeholderRule{scopeID: global{}, span: S, kind: "relation"} :-
  ast.rule{id: RuleID} &
  ast.disjunct{id: DisjunctID, parentID: RuleID} &
  ast.conjunct{id: ConjunctID, parentID: DisjunctID} &
  ast.record{id: RecordID, parentID: ConjunctID} &
  ast.placeholder{parentID: RecordID, span: S}.
scope.placeholderAttr{scopeID: Relation, span: S, kind: "attr"} :-
  ast.conjunct{id: Conjunct} &
  ast.record{id: Rec, parentID: Conjunct} &
  ast.ident{parentID: Rec, text: Relation} &
  ast.keyValue{id: KV, parentID: Rec} &
  ast.placeholder{parentID: KV, span: S}.

# TODO: make autocompletion work inside of negations
# maybe by using scope.parent instead of explicitly joining down

# TODO: var in head that's unbound
tc.Problem{desc: D, nodeID: I, span: S} :-
  tc.nonexistentAttr{desc: D, nodeID: I, span: S} |
  tc.unboundVarInHead{desc: D, nodeID: I, span: S}.
tc.nonexistentAttr{
  desc: nonexistentAttr{relation: Relation, attr: N},
  nodeID: I,
  span: S
} :-
  scope.defnRule{name: Relation} &
  scope.varAttr{scopeID: Relation, nodeID: I, name: N, span: S} &
  !tc.ruleAttr{rule: Relation, attr: N}.
tc.unboundVarInHead{desc: unboundVarInHead{rule: R, name: N}, nodeID: I, span: S} :-
  scope.defnVar{scopeID: RuleID, span: S, name: N} &
  scope.rule{scopeID: RuleID, name: R} &
  !scope.varTerm{scopeID: RuleID, name: N}.

scope.rule{scopeID: RuleID, name: N, span: S} :-
  ast.rule{id: RuleID} &
  ast.record{id: RecordID, parentID: RuleID} &
  ast.ident{parentID: RecordID, text: N, span: S}.

tc.ruleAttr{rule: RuleName, attr: Attr, span: S} :-
  ast.rule{id: Rule} &
  ast.record{id: Rec, parentID: Rule} &
  ast.ident{parentID: Rec, text: RuleName} &
  ast.keyValue{id: KV, parentID: Rec} &
  ast.ident{parentID: KV, text: Attr, span: S}.

hl.mapping{rule: "ident", type: "ident"}.
hl.mapping{rule: "var", type: "specialVar"}.
hl.mapping{rule: "int", type: "int"}.
hl.mapping{rule: "bool", type: "bool"}.
hl.mapping{rule: "string", type: "string"}.
hl.mapping{rule: "comment", type: "comment"}.
hl.mapping{rule: "tableKW", type: "keyword"}.
