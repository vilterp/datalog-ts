// generated by parserlib; do not edit.
import {
  textForSpan,
  childByName,
  childrenByName,
  RuleTree,
  extractRuleTree,
} from "../../parserlib/ruleTree";
import { Span, Grammar } from "../../parserlib/types";
import * as parserlib from "../../parserlib/parser";
export type BBAlpha = {
  type: "Alpha";
  text: string;
  span: Span;
};
export type BBAlphaNum = BBAlpha | BBNum;
export type BBClause = BBRecord | BBComparison;
export type BBCommaSpace = {
  type: "CommaSpace";
  text: string;
  span: Span;
};
export type BBCommaWS = {
  type: "CommaWS";
  text: string;
  span: Span;
};
export type BBComparison = {
  type: "Comparison";
  text: string;
  span: Span;
  left: BBTerm;
  comparisonOp: BBComparisonOp;
  right: BBTerm;
};
export type BBComparisonOp = {
  type: "ComparisonOp";
  text: string;
  span: Span;
};
export type BBConjuncts = {
  type: "Conjuncts";
  text: string;
  span: Span;
  clause: BBClause[];
};
export type BBConstraint = {
  type: "Constraint";
  text: string;
  span: Span;
  ruleKW: BBRuleKW;
  record: BBRecord;
  conjuncts: BBConjuncts;
  sepKW: BBSepKW;
  constraintComparison: BBConstraintComparison;
};
export type BBConstraintComparison = {
  type: "ConstraintComparison";
  text: string;
  span: Span;
  left: BBScalarExpr;
  comparisonOp: BBComparisonOp;
  right: BBScalarExpr;
};
export type BBDeclaration =
  | BBVarRelationDecl
  | BBInputRelationDecl
  | BBObjective
  | BBConstraint;
export type BBIdent = {
  type: "Ident";
  text: string;
  span: Span;
  alpha: BBAlpha;
  alphaNum: BBAlphaNum[];
};
export type BBInputKW = {
  type: "InputKW";
  text: string;
  span: Span;
};
export type BBInputRelationDecl = {
  type: "InputRelationDecl";
  text: string;
  span: Span;
  inputKW: BBInputKW;
  ident: BBIdent;
  schemaSpec: BBSchemaSpec;
};
export type BBInt = {
  type: "Int";
  text: string;
  span: Span;
  first: BBNum;
  num: BBNum[];
};
export type BBMain = {
  type: "Main";
  text: string;
  span: Span;
  declaration: BBDeclaration[];
};
export type BBNum = {
  type: "Num";
  text: string;
  span: Span;
};
export type BBObjective = {
  type: "Objective";
  text: string;
  span: Span;
  sense: BBSense;
  conjuncts: BBConjuncts;
  sepKW: BBSepKW;
  scalarExpr: BBScalarExpr;
};
export type BBPlaceholder = {
  type: "Placeholder";
  text: string;
  span: Span;
};
export type BBRecord = {
  type: "Record";
  text: string;
  span: Span;
  ident: BBIdent;
  recordAttrs: BBRecordAttrs;
};
export type BBRecordAttrs = {
  type: "RecordAttrs";
  text: string;
  span: Span;
  recordKeyValue: BBRecordKeyValue[];
  placeholder: BBPlaceholder[];
  commaSpace: BBCommaSpace[];
};
export type BBRecordKeyValue = {
  type: "RecordKeyValue";
  text: string;
  span: Span;
  ident: BBIdent;
  term: BBTerm;
};
export type BBRuleKW = {
  type: "RuleKW";
  text: string;
  span: Span;
};
export type BBScalarExpr = {
  type: "ScalarExpr";
  text: string;
  span: Span;
  scalarTerm: BBScalarTerm[];
};
export type BBScalarTerm = {
  type: "ScalarTerm";
  text: string;
  span: Span;
  coefficient: BBTerm | null;
  term: BBTerm;
};
export type BBSchemaSpec = {
  type: "SchemaSpec";
  text: string;
  span: Span;
  ident: BBIdent[];
};
export type BBSense = {
  type: "Sense";
  text: string;
  span: Span;
};
export type BBSepKW = {
  type: "SepKW";
  text: string;
  span: Span;
};
export type BBString = {
  type: "String";
  text: string;
  span: Span;
  stringChar: BBStringChar[];
};
export type BBStringChar = {
  type: "StringChar";
  text: string;
  span: Span;
};
export type BBTerm = BBRecord | BBInt | BBVar | BBString | BBPlaceholder;
export type BBVar = {
  type: "Var";
  text: string;
  span: Span;
  alphaNum: BBAlphaNum[];
};
export type BBVarKW = {
  type: "VarKW";
  text: string;
  span: Span;
};
export type BBVarRelationDecl = {
  type: "VarRelationDecl";
  text: string;
  span: Span;
  varKW: BBVarKW;
  ident: BBIdent;
  schemaSpec: BBSchemaSpec;
};
export type BBWs = {
  type: "Ws";
  text: string;
  span: Span;
};
export function parseAlpha(input: string): BBAlpha {
  const traceTree = parserlib.parse(GRAMMAR, "alpha", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlpha(input, ruleTree);
}
export function parseAlphaNum(input: string): BBAlphaNum {
  const traceTree = parserlib.parse(GRAMMAR, "alphaNum", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlphaNum(input, ruleTree);
}
export function parseClause(input: string): BBClause {
  const traceTree = parserlib.parse(GRAMMAR, "clause", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractClause(input, ruleTree);
}
export function parseCommaSpace(input: string): BBCommaSpace {
  const traceTree = parserlib.parse(GRAMMAR, "commaSpace", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaSpace(input, ruleTree);
}
export function parseCommaWS(input: string): BBCommaWS {
  const traceTree = parserlib.parse(GRAMMAR, "commaWS", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaWS(input, ruleTree);
}
export function parseComparison(input: string): BBComparison {
  const traceTree = parserlib.parse(GRAMMAR, "comparison", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractComparison(input, ruleTree);
}
export function parseComparisonOp(input: string): BBComparisonOp {
  const traceTree = parserlib.parse(GRAMMAR, "comparisonOp", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractComparisonOp(input, ruleTree);
}
export function parseConjuncts(input: string): BBConjuncts {
  const traceTree = parserlib.parse(GRAMMAR, "conjuncts", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConjuncts(input, ruleTree);
}
export function parseConstraint(input: string): BBConstraint {
  const traceTree = parserlib.parse(GRAMMAR, "constraint", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConstraint(input, ruleTree);
}
export function parseConstraintComparison(
  input: string
): BBConstraintComparison {
  const traceTree = parserlib.parse(GRAMMAR, "constraintComparison", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConstraintComparison(input, ruleTree);
}
export function parseDeclaration(input: string): BBDeclaration {
  const traceTree = parserlib.parse(GRAMMAR, "declaration", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractDeclaration(input, ruleTree);
}
export function parseIdent(input: string): BBIdent {
  const traceTree = parserlib.parse(GRAMMAR, "ident", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractIdent(input, ruleTree);
}
export function parseInputKW(input: string): BBInputKW {
  const traceTree = parserlib.parse(GRAMMAR, "inputKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInputKW(input, ruleTree);
}
export function parseInputRelationDecl(input: string): BBInputRelationDecl {
  const traceTree = parserlib.parse(GRAMMAR, "inputRelationDecl", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInputRelationDecl(input, ruleTree);
}
export function parseInt(input: string): BBInt {
  const traceTree = parserlib.parse(GRAMMAR, "int", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInt(input, ruleTree);
}
export function parseMain(input: string): BBMain {
  const traceTree = parserlib.parse(GRAMMAR, "main", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractMain(input, ruleTree);
}
export function parseNum(input: string): BBNum {
  const traceTree = parserlib.parse(GRAMMAR, "num", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNum(input, ruleTree);
}
export function parseObjective(input: string): BBObjective {
  const traceTree = parserlib.parse(GRAMMAR, "objective", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractObjective(input, ruleTree);
}
export function parsePlaceholder(input: string): BBPlaceholder {
  const traceTree = parserlib.parse(GRAMMAR, "placeholder", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPlaceholder(input, ruleTree);
}
export function parseRecord(input: string): BBRecord {
  const traceTree = parserlib.parse(GRAMMAR, "record", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecord(input, ruleTree);
}
export function parseRecordAttrs(input: string): BBRecordAttrs {
  const traceTree = parserlib.parse(GRAMMAR, "recordAttrs", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecordAttrs(input, ruleTree);
}
export function parseRecordKeyValue(input: string): BBRecordKeyValue {
  const traceTree = parserlib.parse(GRAMMAR, "recordKeyValue", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecordKeyValue(input, ruleTree);
}
export function parseRuleKW(input: string): BBRuleKW {
  const traceTree = parserlib.parse(GRAMMAR, "ruleKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRuleKW(input, ruleTree);
}
export function parseScalarExpr(input: string): BBScalarExpr {
  const traceTree = parserlib.parse(GRAMMAR, "scalarExpr", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarExpr(input, ruleTree);
}
export function parseScalarTerm(input: string): BBScalarTerm {
  const traceTree = parserlib.parse(GRAMMAR, "scalarTerm", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarTerm(input, ruleTree);
}
export function parseSchemaSpec(input: string): BBSchemaSpec {
  const traceTree = parserlib.parse(GRAMMAR, "schemaSpec", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSchemaSpec(input, ruleTree);
}
export function parseSense(input: string): BBSense {
  const traceTree = parserlib.parse(GRAMMAR, "sense", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSense(input, ruleTree);
}
export function parseSepKW(input: string): BBSepKW {
  const traceTree = parserlib.parse(GRAMMAR, "sepKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSepKW(input, ruleTree);
}
export function parseString(input: string): BBString {
  const traceTree = parserlib.parse(GRAMMAR, "string", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractString(input, ruleTree);
}
export function parseStringChar(input: string): BBStringChar {
  const traceTree = parserlib.parse(GRAMMAR, "stringChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractStringChar(input, ruleTree);
}
export function parseTerm(input: string): BBTerm {
  const traceTree = parserlib.parse(GRAMMAR, "term", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractTerm(input, ruleTree);
}
export function parseVar(input: string): BBVar {
  const traceTree = parserlib.parse(GRAMMAR, "var", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVar(input, ruleTree);
}
export function parseVarKW(input: string): BBVarKW {
  const traceTree = parserlib.parse(GRAMMAR, "varKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVarKW(input, ruleTree);
}
export function parseVarRelationDecl(input: string): BBVarRelationDecl {
  const traceTree = parserlib.parse(GRAMMAR, "varRelationDecl", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVarRelationDecl(input, ruleTree);
}
function extractAlpha(input: string, node: RuleTree): BBAlpha {
  return {
    type: "Alpha",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractAlphaNum(input: string, node: RuleTree): BBAlphaNum {
  const child = node.children[0];
  switch (child.name) {
    case "alpha": {
      return extractAlpha(input, child);
    }
    case "num": {
      return extractNum(input, child);
    }
  }
}
function extractClause(input: string, node: RuleTree): BBClause {
  const child = node.children[0];
  switch (child.name) {
    case "record": {
      return extractRecord(input, child);
    }
    case "comparison": {
      return extractComparison(input, child);
    }
  }
}
function extractCommaSpace(input: string, node: RuleTree): BBCommaSpace {
  return {
    type: "CommaSpace",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractCommaWS(input: string, node: RuleTree): BBCommaWS {
  return {
    type: "CommaWS",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractComparison(input: string, node: RuleTree): BBComparison {
  return {
    type: "Comparison",
    text: textForSpan(input, node.span),
    span: node.span,
    left: extractTerm(input, childByName(node, "term", "left")),
    comparisonOp: extractComparisonOp(
      input,
      childByName(node, "comparisonOp", null)
    ),
    right: extractTerm(input, childByName(node, "term", "right")),
  };
}
function extractComparisonOp(input: string, node: RuleTree): BBComparisonOp {
  return {
    type: "ComparisonOp",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractConjuncts(input: string, node: RuleTree): BBConjuncts {
  return {
    type: "Conjuncts",
    text: textForSpan(input, node.span),
    span: node.span,
    clause: childrenByName(node, "clause").map((child) =>
      extractClause(input, child)
    ),
  };
}
function extractConstraint(input: string, node: RuleTree): BBConstraint {
  return {
    type: "Constraint",
    text: textForSpan(input, node.span),
    span: node.span,
    ruleKW: extractRuleKW(input, childByName(node, "ruleKW", null)),
    record: extractRecord(input, childByName(node, "record", null)),
    conjuncts: extractConjuncts(input, childByName(node, "conjuncts", null)),
    sepKW: extractSepKW(input, childByName(node, "sepKW", null)),
    constraintComparison: extractConstraintComparison(
      input,
      childByName(node, "constraintComparison", null)
    ),
  };
}
function extractConstraintComparison(
  input: string,
  node: RuleTree
): BBConstraintComparison {
  return {
    type: "ConstraintComparison",
    text: textForSpan(input, node.span),
    span: node.span,
    left: extractScalarExpr(input, childByName(node, "scalarExpr", "left")),
    comparisonOp: extractComparisonOp(
      input,
      childByName(node, "comparisonOp", null)
    ),
    right: extractScalarExpr(input, childByName(node, "scalarExpr", "right")),
  };
}
function extractDeclaration(input: string, node: RuleTree): BBDeclaration {
  const child = node.children[0];
  switch (child.name) {
    case "varRelationDecl": {
      return extractVarRelationDecl(input, child);
    }
    case "inputRelationDecl": {
      return extractInputRelationDecl(input, child);
    }
    case "objective": {
      return extractObjective(input, child);
    }
    case "constraint": {
      return extractConstraint(input, child);
    }
  }
}
function extractIdent(input: string, node: RuleTree): BBIdent {
  return {
    type: "Ident",
    text: textForSpan(input, node.span),
    span: node.span,
    alpha: extractAlpha(input, childByName(node, "alpha", null)),
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractInputKW(input: string, node: RuleTree): BBInputKW {
  return {
    type: "InputKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractInputRelationDecl(
  input: string,
  node: RuleTree
): BBInputRelationDecl {
  return {
    type: "InputRelationDecl",
    text: textForSpan(input, node.span),
    span: node.span,
    inputKW: extractInputKW(input, childByName(node, "inputKW", null)),
    ident: extractIdent(input, childByName(node, "ident", null)),
    schemaSpec: extractSchemaSpec(input, childByName(node, "schemaSpec", null)),
  };
}
function extractInt(input: string, node: RuleTree): BBInt {
  return {
    type: "Int",
    text: textForSpan(input, node.span),
    span: node.span,
    first: extractNum(input, childByName(node, "num", "first")),
    num: childrenByName(node, "num").map((child) => extractNum(input, child)),
  };
}
function extractMain(input: string, node: RuleTree): BBMain {
  return {
    type: "Main",
    text: textForSpan(input, node.span),
    span: node.span,
    declaration: childrenByName(node, "declaration").map((child) =>
      extractDeclaration(input, child)
    ),
  };
}
function extractNum(input: string, node: RuleTree): BBNum {
  return {
    type: "Num",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractObjective(input: string, node: RuleTree): BBObjective {
  return {
    type: "Objective",
    text: textForSpan(input, node.span),
    span: node.span,
    sense: extractSense(input, childByName(node, "sense", null)),
    conjuncts: extractConjuncts(input, childByName(node, "conjuncts", null)),
    sepKW: extractSepKW(input, childByName(node, "sepKW", null)),
    scalarExpr: extractScalarExpr(input, childByName(node, "scalarExpr", null)),
  };
}
function extractPlaceholder(input: string, node: RuleTree): BBPlaceholder {
  return {
    type: "Placeholder",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractRecord(input: string, node: RuleTree): BBRecord {
  return {
    type: "Record",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    recordAttrs: extractRecordAttrs(
      input,
      childByName(node, "recordAttrs", null)
    ),
  };
}
function extractRecordAttrs(input: string, node: RuleTree): BBRecordAttrs {
  return {
    type: "RecordAttrs",
    text: textForSpan(input, node.span),
    span: node.span,
    recordKeyValue: childrenByName(node, "recordKeyValue").map((child) =>
      extractRecordKeyValue(input, child)
    ),
    placeholder: childrenByName(node, "placeholder").map((child) =>
      extractPlaceholder(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractRecordKeyValue(
  input: string,
  node: RuleTree
): BBRecordKeyValue {
  return {
    type: "RecordKeyValue",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    term: extractTerm(input, childByName(node, "term", null)),
  };
}
function extractRuleKW(input: string, node: RuleTree): BBRuleKW {
  return {
    type: "RuleKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractScalarExpr(input: string, node: RuleTree): BBScalarExpr {
  return {
    type: "ScalarExpr",
    text: textForSpan(input, node.span),
    span: node.span,
    scalarTerm: childrenByName(node, "scalarTerm").map((child) =>
      extractScalarTerm(input, child)
    ),
  };
}
function extractScalarTerm(input: string, node: RuleTree): BBScalarTerm {
  return {
    type: "ScalarTerm",
    text: textForSpan(input, node.span),
    span: node.span,
    coefficient: childByName(node, "term", "coefficient")
      ? extractTerm(input, childByName(node, "term", "coefficient"))
      : null,
    term: extractTerm(input, childByName(node, "term", "term")),
  };
}
function extractSchemaSpec(input: string, node: RuleTree): BBSchemaSpec {
  return {
    type: "SchemaSpec",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: childrenByName(node, "ident").map((child) =>
      extractIdent(input, child)
    ),
  };
}
function extractSense(input: string, node: RuleTree): BBSense {
  return {
    type: "Sense",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractSepKW(input: string, node: RuleTree): BBSepKW {
  return {
    type: "SepKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractString(input: string, node: RuleTree): BBString {
  return {
    type: "String",
    text: textForSpan(input, node.span),
    span: node.span,
    stringChar: childrenByName(node, "stringChar").map((child) =>
      extractStringChar(input, child)
    ),
  };
}
function extractStringChar(input: string, node: RuleTree): BBStringChar {
  return {
    type: "StringChar",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractTerm(input: string, node: RuleTree): BBTerm {
  const child = node.children[0];
  switch (child.name) {
    case "record": {
      return extractRecord(input, child);
    }
    case "int": {
      return extractInt(input, child);
    }
    case "var": {
      return extractVar(input, child);
    }
    case "string": {
      return extractString(input, child);
    }
    case "placeholder": {
      return extractPlaceholder(input, child);
    }
  }
}
function extractVar(input: string, node: RuleTree): BBVar {
  return {
    type: "Var",
    text: textForSpan(input, node.span),
    span: node.span,
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractVarKW(input: string, node: RuleTree): BBVarKW {
  return {
    type: "VarKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractVarRelationDecl(
  input: string,
  node: RuleTree
): BBVarRelationDecl {
  return {
    type: "VarRelationDecl",
    text: textForSpan(input, node.span),
    span: node.span,
    varKW: extractVarKW(input, childByName(node, "varKW", null)),
    ident: extractIdent(input, childByName(node, "ident", null)),
    schemaSpec: extractSchemaSpec(input, childByName(node, "schemaSpec", null)),
  };
}
const GRAMMAR: Grammar = {
  main: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "declaration",
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "ws",
    },
  },
  declaration: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "varRelationDecl",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "inputRelationDecl",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "objective",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "constraint",
      },
    ],
  },
  varRelationDecl: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "varKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "schemaSpec",
      },
    ],
  },
  inputRelationDecl: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "inputKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "schemaSpec",
      },
    ],
  },
  schemaSpec: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "ident",
        },
        sep: {
          type: "Sequence",
          items: [
            {
              type: "Text",
              value: ",",
            },
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
          ],
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  objective: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "sense",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "conjuncts",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "sepKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "scalarExpr",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  constraint: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ruleKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "conjuncts",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "sepKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "constraintComparison",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  constraintComparison: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: "left",
        rule: "scalarExpr",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparisonOp",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: "right",
        rule: "scalarExpr",
      },
    ],
  },
  conjuncts: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "clause",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "&",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  clause: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparison",
      },
    ],
  },
  scalarExpr: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "scalarTerm",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "+",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  scalarTerm: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Sequence",
            items: [
              {
                type: "Ref",
                captureName: "coefficient",
                rule: "term",
              },
              {
                type: "Ref",
                captureName: null,
                rule: "ws",
              },
              {
                type: "Text",
                value: "*",
              },
              {
                type: "Ref",
                captureName: null,
                rule: "ws",
              },
            ],
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: "term",
        rule: "term",
      },
    ],
  },
  comparison: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: "left",
        rule: "term",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparisonOp",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: "right",
        rule: "term",
      },
    ],
  },
  comparisonOp: {
    type: "Choice",
    choices: [
      {
        type: "Text",
        value: "<=",
      },
      {
        type: "Text",
        value: ">=",
      },
      {
        type: "Text",
        value: ">",
      },
      {
        type: "Text",
        value: "<",
      },
      {
        type: "Text",
        value: "=",
      },
      {
        type: "Text",
        value: "!=",
      },
    ],
  },
  record: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "recordAttrs",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  recordAttrs: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Ref",
          captureName: null,
          rule: "recordKeyValue",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "placeholder",
        },
      ],
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "commaSpace",
    },
  },
  recordKeyValue: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Text",
        value: ":",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "term",
      },
    ],
  },
  term: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "int",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "var",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "string",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "placeholder",
      },
    ],
  },
  var: {
    type: "Sequence",
    items: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Char",
              rule: {
                type: "Range",
                from: "A",
                to: "Z",
              },
            },
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  sense: {
    type: "Choice",
    choices: [
      {
        type: "Text",
        value: "minimize",
      },
      {
        type: "Text",
        value: "maximize",
      },
    ],
  },
  varKW: {
    type: "Text",
    value: "var",
  },
  inputKW: {
    type: "Text",
    value: "input",
  },
  ruleKW: {
    type: "Text",
    value: "rule",
  },
  sepKW: {
    type: "Text",
    value: "=>",
  },
  ident: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
            {
              type: "Text",
              value: ".",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  int: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Text",
            value: "-",
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: "first",
        rule: "num",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "num",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  string: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: '"',
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "stringChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
      {
        type: "Text",
        value: '"',
      },
    ],
  },
  stringChar: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Not",
          rule: {
            type: "Literal",
            value: '"',
          },
        },
      },
      {
        type: "Sequence",
        items: [
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: "\\",
            },
          },
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: '"',
            },
          },
        ],
      },
    ],
  },
  alpha: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "a",
          to: "z",
        },
      },
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "Text",
        value: "_",
      },
    ],
  },
  num: {
    type: "Char",
    rule: {
      type: "Range",
      from: "0",
      to: "9",
    },
  },
  alphaNum: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "num",
      },
    ],
  },
  ws: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Text",
          value: " ",
        },
        {
          type: "Text",
          value: "\n",
        },
      ],
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  commaWS: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
  placeholder: {
    type: "Text",
    value: "???",
  },
  commaSpace: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
};
