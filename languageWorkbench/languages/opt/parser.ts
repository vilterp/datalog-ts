// generated by parserlib; do not edit.
import {
  textForSpan,
  childByName,
  childrenByName,
  RuleTree,
  extractRuleTree,
} from "../../parserlib/ruleTree";
import { Span, Grammar } from "../../parserlib/types";
import * as parserlib from "../../parserlib/parser";
export type OptAlpha = {
  type: "Alpha";
  text: string;
  span: Span;
};
export type OptAlphaNum = OptAlpha | OptNum;
export type OptClause = OptRecord | OptComparison;
export type OptCommaSpace = {
  type: "CommaSpace";
  text: string;
  span: Span;
};
export type OptCommaWS = {
  type: "CommaWS";
  text: string;
  span: Span;
};
export type OptComparison = {
  type: "Comparison";
  text: string;
  span: Span;
  left: OptTerm;
  comparisonOp: OptComparisonOp;
  right: OptTerm;
};
export type OptComparisonOp = {
  type: "ComparisonOp";
  text: string;
  span: Span;
};
export type OptConjuncts = {
  type: "Conjuncts";
  text: string;
  span: Span;
  clause: OptClause[];
};
export type OptConstraint = {
  type: "Constraint";
  text: string;
  span: Span;
  ruleKW: OptRuleKW;
  record: OptRecord;
  conjuncts: OptConjuncts;
  sepKW: OptSepKW;
  constraintComparison: OptConstraintComparison;
};
export type OptConstraintComparison = {
  type: "ConstraintComparison";
  text: string;
  span: Span;
  left: OptScalarExpr;
  comparisonOp: OptComparisonOp;
  right: OptScalarExpr;
};
export type OptDeclaration =
  | OptVarRelationDecl
  | OptInputRelationDecl
  | OptObjective
  | OptConstraint;
export type OptIdent = {
  type: "Ident";
  text: string;
  span: Span;
  alpha: OptAlpha;
  alphaNum: OptAlphaNum[];
};
export type OptInputKW = {
  type: "InputKW";
  text: string;
  span: Span;
};
export type OptInputRelationDecl = {
  type: "InputRelationDecl";
  text: string;
  span: Span;
  inputKW: OptInputKW;
  ident: OptIdent;
  schemaSpec: OptSchemaSpec;
};
export type OptInt = {
  type: "Int";
  text: string;
  span: Span;
  first: OptNum;
  num: OptNum[];
};
export type OptMain = {
  type: "Main";
  text: string;
  span: Span;
  declaration: OptDeclaration[];
};
export type OptNum = {
  type: "Num";
  text: string;
  span: Span;
};
export type OptObjective = {
  type: "Objective";
  text: string;
  span: Span;
  sense: OptSense;
  conjuncts: OptConjuncts;
  sepKW: OptSepKW;
  scalarExpr: OptScalarExpr;
};
export type OptPlaceholder = {
  type: "Placeholder";
  text: string;
  span: Span;
};
export type OptRecord = {
  type: "Record";
  text: string;
  span: Span;
  ident: OptIdent;
  recordAttrs: OptRecordAttrs;
};
export type OptRecordAttrs = {
  type: "RecordAttrs";
  text: string;
  span: Span;
  recordKeyValue: OptRecordKeyValue[];
  placeholder: OptPlaceholder[];
  commaSpace: OptCommaSpace[];
};
export type OptRecordKeyValue = {
  type: "RecordKeyValue";
  text: string;
  span: Span;
  ident: OptIdent;
  term: OptTerm;
};
export type OptRuleKW = {
  type: "RuleKW";
  text: string;
  span: Span;
};
export type OptScalarExpr = {
  type: "ScalarExpr";
  text: string;
  span: Span;
  scalarTerm: OptScalarTerm[];
};
export type OptScalarTerm = {
  type: "ScalarTerm";
  text: string;
  span: Span;
  coefficient: OptTerm | null;
  term: OptTerm;
};
export type OptSchemaSpec = {
  type: "SchemaSpec";
  text: string;
  span: Span;
  ident: OptIdent[];
};
export type OptSense = {
  type: "Sense";
  text: string;
  span: Span;
};
export type OptSepKW = {
  type: "SepKW";
  text: string;
  span: Span;
};
export type OptString = {
  type: "String";
  text: string;
  span: Span;
  stringChar: OptStringChar[];
};
export type OptStringChar = {
  type: "StringChar";
  text: string;
  span: Span;
};
export type OptTerm = OptRecord | OptInt | OptVar | OptString | OptPlaceholder;
export type OptVar = {
  type: "Var";
  text: string;
  span: Span;
  alphaNum: OptAlphaNum[];
};
export type OptVarKW = {
  type: "VarKW";
  text: string;
  span: Span;
};
export type OptVarRelationDecl = {
  type: "VarRelationDecl";
  text: string;
  span: Span;
  varKW: OptVarKW;
  ident: OptIdent;
  schemaSpec: OptSchemaSpec;
};
export type OptWs = {
  type: "Ws";
  text: string;
  span: Span;
};
export function parseAlpha(input: string): OptAlpha {
  const traceTree = parserlib.parse(GRAMMAR, "alpha", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlpha(input, ruleTree);
}
export function parseAlphaNum(input: string): OptAlphaNum {
  const traceTree = parserlib.parse(GRAMMAR, "alphaNum", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractAlphaNum(input, ruleTree);
}
export function parseClause(input: string): OptClause {
  const traceTree = parserlib.parse(GRAMMAR, "clause", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractClause(input, ruleTree);
}
export function parseCommaSpace(input: string): OptCommaSpace {
  const traceTree = parserlib.parse(GRAMMAR, "commaSpace", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaSpace(input, ruleTree);
}
export function parseCommaWS(input: string): OptCommaWS {
  const traceTree = parserlib.parse(GRAMMAR, "commaWS", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractCommaWS(input, ruleTree);
}
export function parseComparison(input: string): OptComparison {
  const traceTree = parserlib.parse(GRAMMAR, "comparison", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractComparison(input, ruleTree);
}
export function parseComparisonOp(input: string): OptComparisonOp {
  const traceTree = parserlib.parse(GRAMMAR, "comparisonOp", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractComparisonOp(input, ruleTree);
}
export function parseConjuncts(input: string): OptConjuncts {
  const traceTree = parserlib.parse(GRAMMAR, "conjuncts", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConjuncts(input, ruleTree);
}
export function parseConstraint(input: string): OptConstraint {
  const traceTree = parserlib.parse(GRAMMAR, "constraint", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConstraint(input, ruleTree);
}
export function parseConstraintComparison(
  input: string
): OptConstraintComparison {
  const traceTree = parserlib.parse(GRAMMAR, "constraintComparison", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractConstraintComparison(input, ruleTree);
}
export function parseDeclaration(input: string): OptDeclaration {
  const traceTree = parserlib.parse(GRAMMAR, "declaration", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractDeclaration(input, ruleTree);
}
export function parseIdent(input: string): OptIdent {
  const traceTree = parserlib.parse(GRAMMAR, "ident", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractIdent(input, ruleTree);
}
export function parseInputKW(input: string): OptInputKW {
  const traceTree = parserlib.parse(GRAMMAR, "inputKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInputKW(input, ruleTree);
}
export function parseInputRelationDecl(input: string): OptInputRelationDecl {
  const traceTree = parserlib.parse(GRAMMAR, "inputRelationDecl", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInputRelationDecl(input, ruleTree);
}
export function parseInt(input: string): OptInt {
  const traceTree = parserlib.parse(GRAMMAR, "int", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractInt(input, ruleTree);
}
export function parseMain(input: string): OptMain {
  const traceTree = parserlib.parse(GRAMMAR, "main", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractMain(input, ruleTree);
}
export function parseNum(input: string): OptNum {
  const traceTree = parserlib.parse(GRAMMAR, "num", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractNum(input, ruleTree);
}
export function parseObjective(input: string): OptObjective {
  const traceTree = parserlib.parse(GRAMMAR, "objective", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractObjective(input, ruleTree);
}
export function parsePlaceholder(input: string): OptPlaceholder {
  const traceTree = parserlib.parse(GRAMMAR, "placeholder", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractPlaceholder(input, ruleTree);
}
export function parseRecord(input: string): OptRecord {
  const traceTree = parserlib.parse(GRAMMAR, "record", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecord(input, ruleTree);
}
export function parseRecordAttrs(input: string): OptRecordAttrs {
  const traceTree = parserlib.parse(GRAMMAR, "recordAttrs", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecordAttrs(input, ruleTree);
}
export function parseRecordKeyValue(input: string): OptRecordKeyValue {
  const traceTree = parserlib.parse(GRAMMAR, "recordKeyValue", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRecordKeyValue(input, ruleTree);
}
export function parseRuleKW(input: string): OptRuleKW {
  const traceTree = parserlib.parse(GRAMMAR, "ruleKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractRuleKW(input, ruleTree);
}
export function parseScalarExpr(input: string): OptScalarExpr {
  const traceTree = parserlib.parse(GRAMMAR, "scalarExpr", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarExpr(input, ruleTree);
}
export function parseScalarTerm(input: string): OptScalarTerm {
  const traceTree = parserlib.parse(GRAMMAR, "scalarTerm", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractScalarTerm(input, ruleTree);
}
export function parseSchemaSpec(input: string): OptSchemaSpec {
  const traceTree = parserlib.parse(GRAMMAR, "schemaSpec", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSchemaSpec(input, ruleTree);
}
export function parseSense(input: string): OptSense {
  const traceTree = parserlib.parse(GRAMMAR, "sense", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSense(input, ruleTree);
}
export function parseSepKW(input: string): OptSepKW {
  const traceTree = parserlib.parse(GRAMMAR, "sepKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractSepKW(input, ruleTree);
}
export function parseString(input: string): OptString {
  const traceTree = parserlib.parse(GRAMMAR, "string", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractString(input, ruleTree);
}
export function parseStringChar(input: string): OptStringChar {
  const traceTree = parserlib.parse(GRAMMAR, "stringChar", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractStringChar(input, ruleTree);
}
export function parseTerm(input: string): OptTerm {
  const traceTree = parserlib.parse(GRAMMAR, "term", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractTerm(input, ruleTree);
}
export function parseVar(input: string): OptVar {
  const traceTree = parserlib.parse(GRAMMAR, "var", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVar(input, ruleTree);
}
export function parseVarKW(input: string): OptVarKW {
  const traceTree = parserlib.parse(GRAMMAR, "varKW", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVarKW(input, ruleTree);
}
export function parseVarRelationDecl(input: string): OptVarRelationDecl {
  const traceTree = parserlib.parse(GRAMMAR, "varRelationDecl", input);
  const ruleTree = extractRuleTree(traceTree);
  return extractVarRelationDecl(input, ruleTree);
}
function extractAlpha(input: string, node: RuleTree): OptAlpha {
  return {
    type: "Alpha",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractAlphaNum(input: string, node: RuleTree): OptAlphaNum {
  const child = node.children[0];
  switch (child.name) {
    case "alpha": {
      return extractAlpha(input, child);
    }
    case "num": {
      return extractNum(input, child);
    }
  }
}
function extractClause(input: string, node: RuleTree): OptClause {
  const child = node.children[0];
  switch (child.name) {
    case "record": {
      return extractRecord(input, child);
    }
    case "comparison": {
      return extractComparison(input, child);
    }
  }
}
function extractCommaSpace(input: string, node: RuleTree): OptCommaSpace {
  return {
    type: "CommaSpace",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractCommaWS(input: string, node: RuleTree): OptCommaWS {
  return {
    type: "CommaWS",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractComparison(input: string, node: RuleTree): OptComparison {
  return {
    type: "Comparison",
    text: textForSpan(input, node.span),
    span: node.span,
    left: extractTerm(input, childByName(node, "term", "left")),
    comparisonOp: extractComparisonOp(
      input,
      childByName(node, "comparisonOp", null)
    ),
    right: extractTerm(input, childByName(node, "term", "right")),
  };
}
function extractComparisonOp(input: string, node: RuleTree): OptComparisonOp {
  return {
    type: "ComparisonOp",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractConjuncts(input: string, node: RuleTree): OptConjuncts {
  return {
    type: "Conjuncts",
    text: textForSpan(input, node.span),
    span: node.span,
    clause: childrenByName(node, "clause").map((child) =>
      extractClause(input, child)
    ),
  };
}
function extractConstraint(input: string, node: RuleTree): OptConstraint {
  return {
    type: "Constraint",
    text: textForSpan(input, node.span),
    span: node.span,
    ruleKW: extractRuleKW(input, childByName(node, "ruleKW", null)),
    record: extractRecord(input, childByName(node, "record", null)),
    conjuncts: extractConjuncts(input, childByName(node, "conjuncts", null)),
    sepKW: extractSepKW(input, childByName(node, "sepKW", null)),
    constraintComparison: extractConstraintComparison(
      input,
      childByName(node, "constraintComparison", null)
    ),
  };
}
function extractConstraintComparison(
  input: string,
  node: RuleTree
): OptConstraintComparison {
  return {
    type: "ConstraintComparison",
    text: textForSpan(input, node.span),
    span: node.span,
    left: extractScalarExpr(input, childByName(node, "scalarExpr", "left")),
    comparisonOp: extractComparisonOp(
      input,
      childByName(node, "comparisonOp", null)
    ),
    right: extractScalarExpr(input, childByName(node, "scalarExpr", "right")),
  };
}
function extractDeclaration(input: string, node: RuleTree): OptDeclaration {
  const child = node.children[0];
  switch (child.name) {
    case "varRelationDecl": {
      return extractVarRelationDecl(input, child);
    }
    case "inputRelationDecl": {
      return extractInputRelationDecl(input, child);
    }
    case "objective": {
      return extractObjective(input, child);
    }
    case "constraint": {
      return extractConstraint(input, child);
    }
  }
}
function extractIdent(input: string, node: RuleTree): OptIdent {
  return {
    type: "Ident",
    text: textForSpan(input, node.span),
    span: node.span,
    alpha: extractAlpha(input, childByName(node, "alpha", null)),
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractInputKW(input: string, node: RuleTree): OptInputKW {
  return {
    type: "InputKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractInputRelationDecl(
  input: string,
  node: RuleTree
): OptInputRelationDecl {
  return {
    type: "InputRelationDecl",
    text: textForSpan(input, node.span),
    span: node.span,
    inputKW: extractInputKW(input, childByName(node, "inputKW", null)),
    ident: extractIdent(input, childByName(node, "ident", null)),
    schemaSpec: extractSchemaSpec(input, childByName(node, "schemaSpec", null)),
  };
}
function extractInt(input: string, node: RuleTree): OptInt {
  return {
    type: "Int",
    text: textForSpan(input, node.span),
    span: node.span,
    first: extractNum(input, childByName(node, "num", "first")),
    num: childrenByName(node, "num").map((child) => extractNum(input, child)),
  };
}
function extractMain(input: string, node: RuleTree): OptMain {
  return {
    type: "Main",
    text: textForSpan(input, node.span),
    span: node.span,
    declaration: childrenByName(node, "declaration").map((child) =>
      extractDeclaration(input, child)
    ),
  };
}
function extractNum(input: string, node: RuleTree): OptNum {
  return {
    type: "Num",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractObjective(input: string, node: RuleTree): OptObjective {
  return {
    type: "Objective",
    text: textForSpan(input, node.span),
    span: node.span,
    sense: extractSense(input, childByName(node, "sense", null)),
    conjuncts: extractConjuncts(input, childByName(node, "conjuncts", null)),
    sepKW: extractSepKW(input, childByName(node, "sepKW", null)),
    scalarExpr: extractScalarExpr(input, childByName(node, "scalarExpr", null)),
  };
}
function extractPlaceholder(input: string, node: RuleTree): OptPlaceholder {
  return {
    type: "Placeholder",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractRecord(input: string, node: RuleTree): OptRecord {
  return {
    type: "Record",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    recordAttrs: extractRecordAttrs(
      input,
      childByName(node, "recordAttrs", null)
    ),
  };
}
function extractRecordAttrs(input: string, node: RuleTree): OptRecordAttrs {
  return {
    type: "RecordAttrs",
    text: textForSpan(input, node.span),
    span: node.span,
    recordKeyValue: childrenByName(node, "recordKeyValue").map((child) =>
      extractRecordKeyValue(input, child)
    ),
    placeholder: childrenByName(node, "placeholder").map((child) =>
      extractPlaceholder(input, child)
    ),
    commaSpace: childrenByName(node, "commaSpace").map((child) =>
      extractCommaSpace(input, child)
    ),
  };
}
function extractRecordKeyValue(
  input: string,
  node: RuleTree
): OptRecordKeyValue {
  return {
    type: "RecordKeyValue",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: extractIdent(input, childByName(node, "ident", null)),
    term: extractTerm(input, childByName(node, "term", null)),
  };
}
function extractRuleKW(input: string, node: RuleTree): OptRuleKW {
  return {
    type: "RuleKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractScalarExpr(input: string, node: RuleTree): OptScalarExpr {
  return {
    type: "ScalarExpr",
    text: textForSpan(input, node.span),
    span: node.span,
    scalarTerm: childrenByName(node, "scalarTerm").map((child) =>
      extractScalarTerm(input, child)
    ),
  };
}
function extractScalarTerm(input: string, node: RuleTree): OptScalarTerm {
  return {
    type: "ScalarTerm",
    text: textForSpan(input, node.span),
    span: node.span,
    coefficient: childByName(node, "term", "coefficient")
      ? extractTerm(input, childByName(node, "term", "coefficient"))
      : null,
    term: extractTerm(input, childByName(node, "term", "term")),
  };
}
function extractSchemaSpec(input: string, node: RuleTree): OptSchemaSpec {
  return {
    type: "SchemaSpec",
    text: textForSpan(input, node.span),
    span: node.span,
    ident: childrenByName(node, "ident").map((child) =>
      extractIdent(input, child)
    ),
  };
}
function extractSense(input: string, node: RuleTree): OptSense {
  return {
    type: "Sense",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractSepKW(input: string, node: RuleTree): OptSepKW {
  return {
    type: "SepKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractString(input: string, node: RuleTree): OptString {
  return {
    type: "String",
    text: textForSpan(input, node.span),
    span: node.span,
    stringChar: childrenByName(node, "stringChar").map((child) =>
      extractStringChar(input, child)
    ),
  };
}
function extractStringChar(input: string, node: RuleTree): OptStringChar {
  return {
    type: "StringChar",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractTerm(input: string, node: RuleTree): OptTerm {
  const child = node.children[0];
  switch (child.name) {
    case "record": {
      return extractRecord(input, child);
    }
    case "int": {
      return extractInt(input, child);
    }
    case "var": {
      return extractVar(input, child);
    }
    case "string": {
      return extractString(input, child);
    }
    case "placeholder": {
      return extractPlaceholder(input, child);
    }
  }
}
function extractVar(input: string, node: RuleTree): OptVar {
  return {
    type: "Var",
    text: textForSpan(input, node.span),
    span: node.span,
    alphaNum: childrenByName(node, "alphaNum").map((child) =>
      extractAlphaNum(input, child)
    ),
  };
}
function extractVarKW(input: string, node: RuleTree): OptVarKW {
  return {
    type: "VarKW",
    text: textForSpan(input, node.span),
    span: node.span,
  };
}
function extractVarRelationDecl(
  input: string,
  node: RuleTree
): OptVarRelationDecl {
  return {
    type: "VarRelationDecl",
    text: textForSpan(input, node.span),
    span: node.span,
    varKW: extractVarKW(input, childByName(node, "varKW", null)),
    ident: extractIdent(input, childByName(node, "ident", null)),
    schemaSpec: extractSchemaSpec(input, childByName(node, "schemaSpec", null)),
  };
}
const GRAMMAR: Grammar = {
  main: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "declaration",
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "ws",
    },
  },
  declaration: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "varRelationDecl",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "inputRelationDecl",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "objective",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "constraint",
      },
    ],
  },
  varRelationDecl: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "varKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "schemaSpec",
      },
    ],
  },
  inputRelationDecl: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "inputKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "schemaSpec",
      },
    ],
  },
  schemaSpec: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "ident",
        },
        sep: {
          type: "Sequence",
          items: [
            {
              type: "Text",
              value: ",",
            },
            {
              type: "Ref",
              captureName: null,
              rule: "ws",
            },
          ],
        },
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  objective: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "sense",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "conjuncts",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "sepKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "scalarExpr",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  constraint: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ruleKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "conjuncts",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "sepKW",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "constraintComparison",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  constraintComparison: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: "left",
        rule: "scalarExpr",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparisonOp",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: "right",
        rule: "scalarExpr",
      },
    ],
  },
  conjuncts: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "clause",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "&",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  clause: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparison",
      },
    ],
  },
  scalarExpr: {
    type: "RepSep",
    rep: {
      type: "Ref",
      captureName: null,
      rule: "scalarTerm",
    },
    sep: {
      type: "Sequence",
      items: [
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
        {
          type: "Text",
          value: "+",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "ws",
        },
      ],
    },
  },
  scalarTerm: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Sequence",
            items: [
              {
                type: "Ref",
                captureName: "coefficient",
                rule: "term",
              },
              {
                type: "Ref",
                captureName: null,
                rule: "ws",
              },
              {
                type: "Text",
                value: "*",
              },
              {
                type: "Ref",
                captureName: null,
                rule: "ws",
              },
            ],
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: "term",
        rule: "term",
      },
    ],
  },
  comparison: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: "left",
        rule: "term",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "comparisonOp",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: "right",
        rule: "term",
      },
    ],
  },
  comparisonOp: {
    type: "Choice",
    choices: [
      {
        type: "Text",
        value: "<=",
      },
      {
        type: "Text",
        value: ">=",
      },
      {
        type: "Text",
        value: ">",
      },
      {
        type: "Text",
        value: "<",
      },
      {
        type: "Text",
        value: "=",
      },
      {
        type: "Text",
        value: "!=",
      },
    ],
  },
  record: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Text",
        value: "{",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "recordAttrs",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Text",
        value: "}",
      },
    ],
  },
  recordAttrs: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Ref",
          captureName: null,
          rule: "recordKeyValue",
        },
        {
          type: "Ref",
          captureName: null,
          rule: "placeholder",
        },
      ],
    },
    sep: {
      type: "Ref",
      captureName: null,
      rule: "commaSpace",
    },
  },
  recordKeyValue: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "ident",
      },
      {
        type: "Text",
        value: ":",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "term",
      },
    ],
  },
  term: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "record",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "int",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "var",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "string",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "placeholder",
      },
    ],
  },
  var: {
    type: "Sequence",
    items: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Char",
              rule: {
                type: "Range",
                from: "A",
                to: "Z",
              },
            },
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  sense: {
    type: "Choice",
    choices: [
      {
        type: "Text",
        value: "minimize",
      },
      {
        type: "Text",
        value: "maximize",
      },
    ],
  },
  varKW: {
    type: "Text",
    value: "var",
  },
  inputKW: {
    type: "Text",
    value: "input",
  },
  ruleKW: {
    type: "Text",
    value: "rule",
  },
  sepKW: {
    type: "Text",
    value: "=>",
  },
  ident: {
    type: "Sequence",
    items: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "RepSep",
        rep: {
          type: "Choice",
          choices: [
            {
              type: "Ref",
              captureName: null,
              rule: "alphaNum",
            },
            {
              type: "Text",
              value: ".",
            },
          ],
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  int: {
    type: "Sequence",
    items: [
      {
        type: "Choice",
        choices: [
          {
            type: "Text",
            value: "-",
          },
          {
            type: "Text",
            value: "",
          },
        ],
      },
      {
        type: "Ref",
        captureName: "first",
        rule: "num",
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "num",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
    ],
  },
  string: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: '"',
      },
      {
        type: "RepSep",
        rep: {
          type: "Ref",
          captureName: null,
          rule: "stringChar",
        },
        sep: {
          type: "Text",
          value: "",
        },
      },
      {
        type: "Text",
        value: '"',
      },
    ],
  },
  stringChar: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Not",
          rule: {
            type: "Literal",
            value: '"',
          },
        },
      },
      {
        type: "Sequence",
        items: [
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: "\\",
            },
          },
          {
            type: "Char",
            rule: {
              type: "Literal",
              value: '"',
            },
          },
        ],
      },
    ],
  },
  alpha: {
    type: "Choice",
    choices: [
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "a",
          to: "z",
        },
      },
      {
        type: "Char",
        rule: {
          type: "Range",
          from: "A",
          to: "Z",
        },
      },
      {
        type: "Text",
        value: "_",
      },
    ],
  },
  num: {
    type: "Char",
    rule: {
      type: "Range",
      from: "0",
      to: "9",
    },
  },
  alphaNum: {
    type: "Choice",
    choices: [
      {
        type: "Ref",
        captureName: null,
        rule: "alpha",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "num",
      },
    ],
  },
  ws: {
    type: "RepSep",
    rep: {
      type: "Choice",
      choices: [
        {
          type: "Text",
          value: " ",
        },
        {
          type: "Text",
          value: "\n",
        },
      ],
    },
    sep: {
      type: "Text",
      value: "",
    },
  },
  commaWS: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
  placeholder: {
    type: "Text",
    value: "???",
  },
  commaSpace: {
    type: "Sequence",
    items: [
      {
        type: "Text",
        value: ",",
      },
      {
        type: "Ref",
        captureName: null,
        rule: "ws",
      },
    ],
  },
};
