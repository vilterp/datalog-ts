import { BlockStatement } from "estree";
import {
  capitalize,
  filterObj,
  flatMap,
  groupBy,
  mapObj,
  mapObjToList,
} from "../../../util/util";
import {
  jsArrowFunc,
  jsBlock,
  jsCall,
  jsChain,
  jsIdent,
  jsImport,
  jsMember,
  jsObj,
  jsStr,
  prettyPrintProgramWithTypes,
  ProgramWithTypes,
  tsArrayType,
  tsTypeName,
  tsTypedParam,
  TypeDeclaration,
  TypedFunctionDeclaration,
  tsTypeString,
  tsUnionType,
  TypeExpr,
  ObjectLiteralTypeMember,
  jsConstAssn,
  jsReturn,
  jsSwitch,
  jsNull,
  tsOrNull,
  jsTernary,
} from "./astHelpers";
import { Grammar, Rule } from "../types";

export type Options = {
  parserlibPath: string;
  typePrefix: string;
  ignoreRules: Set<string>;
};

export function genExtractorStr(options: Options, grammar: Grammar) {
  const program = genExtractor(options, grammar);
  return prettyPrintProgramWithTypes(program);
}

export function genExtractor(
  options: Options,
  grammar: Grammar
): ProgramWithTypes {
  return {
    type: "ProgramWithTypes",
    imports: [
      jsImport(`${options.parserlibPath}/ruleTree`, [
        "textForSpan",
        "childByName",
        "childrenByName",
        "RuleTree",
        "extractRuleTree",
      ]),
      jsImport(`${options.parserlibPath}/types`, [
        "Span",
        "Grammar",
        "ParseError",
      ]),
      `import * as parserlib from "${options.parserlibPath}/parser"`,
    ],
    leadingComments: ["generated by parserlib; do not edit."],
    types: mapObjToList(grammar, (name, rule) =>
      typeForRule(name, rule, options)
    ),
    declarations: [
      ...generateEntryPoints(grammar, options),
      ...mapObjToList(
        filterObj(grammar, (name) => !options.ignoreRules.has(name)),
        (name, rule) => genRule(name, rule, options)
      ),
      generateGrammarConst(grammar),
    ],
  };
}

type RefInfo = {
  ruleName: string;
  captureName: string | null;
  origin: RefOrigin;
};

type RefOrigin = {
  repeated: boolean; // whether this was in a repSep
  inChoice: boolean; // whether this was in a choice
};

const initialOrigin: RefOrigin = { inChoice: false, repeated: false };

function refsInRule(rule: Rule): RefInfo[] {
  return refsInRuleInner(rule, initialOrigin);
}

function refsInRuleInner(rule: Rule, origin: RefOrigin): RefInfo[] {
  switch (rule.type) {
    case "Char":
      return [];
    case "Choice":
      return flatMap(rule.choices, (choice) =>
        refsInRuleInner(choice, { ...origin, inChoice: true })
      );
    case "Ref":
      return [{ ruleName: rule.rule, captureName: rule.captureName, origin }];
    case "RepSep":
      if (origin.repeated) {
        throw new Error("can't have repSep inside repSep. define a sub rule");
      }
      return [
        ...refsInRuleInner(rule.rep, { ...origin, repeated: true }),
        ...refsInRuleInner(rule.sep, { ...origin, repeated: true }),
      ];
    case "Sequence":
      return flatMap(rule.items, (item) => refsInRuleInner(item, origin));
    case "Text":
      return [];
  }
}

function genRule(
  ruleName: string,
  rule: Rule,
  options: Options
): TypedFunctionDeclaration {
  return {
    type: "TypedFunctionDeclaration",
    name: extractorName(ruleName),
    returnType: tsTypeName(typeName(ruleName, options.typePrefix)),
    params: [
      tsTypedParam("input", tsTypeName("string")),
      tsTypedParam("node", tsTypeName("RuleTree")),
    ],
    body: extractorBodyForRule(ruleName, rule, options),
  };
}

function extractorBodyForRule(
  ruleName: string,
  rule: Rule,
  options: Options
): BlockStatement {
  const refs = refsInRule(rule);
  const filteredRefs = refs.filter((r) => !options.ignoreRules.has(r.ruleName));
  const refNames = filteredRefs.map((r) => `${r.captureName}:${r.ruleName}`);
  const grouped = groupBy(refNames, (x) => x);
  const counted = mapObj(grouped, (name, refs) => refs.length);
  const duplicated = filterObj(counted, (name, count) => count > 1);
  if (Object.keys(duplicated).length > 0) {
    // TODO: mostly triggered by whitespace rules...
    throw new Error(
      `multiple refs from rule "${ruleName}": ${JSON.stringify(duplicated)}`
    );
  }

  const baseObjMembers = [
    { key: "type", value: jsStr(capitalize(ruleName)) },
    {
      key: "text",
      value: jsCall(jsIdent("textForSpan"), [
        jsIdent("input"),
        jsChain(["node", "span"]),
      ]),
    },
    {
      key: "span",
      value: jsChain(["node", "span"]),
    },
  ];

  if (rule.type === "Choice") {
    if (refs.length === 0) {
      return jsBlock([jsReturn(jsObj(baseObjMembers))]);
    }

    return jsBlock([
      jsConstAssn("child", jsChain(["node", "children", 0])),
      jsSwitch(
        jsChain(["child", "name"]),
        refs.map((ref) => {
          return {
            name: ref.ruleName,
            block: jsBlock([
              jsReturn(
                jsCall(jsIdent(extractorName(ref.ruleName)), [
                  jsIdent("input"),
                  jsIdent("child"),
                ])
              ),
            ]),
          };
        })
      ),
    ]);
  }

  const ruleObjMembers = refs
    .filter((ref) => !options.ignoreRules.has(ref.ruleName))
    .map(({ ruleName, captureName, origin }) => {
      const childByNameCall = jsCall(jsIdent("childByName"), [
        jsIdent("node"),
        jsStr(ruleName),
        captureName ? jsStr(captureName) : jsNull,
      ]);
      return {
        // TODO: pluralize if this is a repSep
        key: prefixToAvoidReserved(captureName ? captureName : ruleName),
        value: origin.repeated
          ? jsCall(
              jsMember(
                jsCall(jsIdent("childrenByName"), [
                  jsIdent("node"),
                  jsStr(ruleName),
                ]),
                "map"
              ),
              [
                jsArrowFunc(
                  ["child"],
                  jsCall(jsIdent(extractorName(ruleName)), [
                    jsIdent("input"),
                    jsIdent("child"),
                  ])
                ),
              ]
            )
          : origin.inChoice
          ? jsTernary(
              childByNameCall,
              jsCall(jsIdent(extractorName(ruleName)), [
                jsIdent("input"),
                childByNameCall,
              ]),
              jsNull
            )
          : jsCall(jsIdent(extractorName(ruleName)), [
              jsIdent("input"),
              childByNameCall,
            ]),
      };
    });

  return jsBlock([jsReturn(jsObj([...baseObjMembers, ...ruleObjMembers]))]);
}

function typeForRule(
  ruleName: string,
  rule: Rule,
  options: Options
): TypeDeclaration {
  return {
    type: "TypeDeclaration",
    name: typeName(ruleName, options.typePrefix),
    exported: true,
    expr: typeExprForRule(ruleName, rule, options),
  };
}

function typeExprForRule(
  ruleName: string,
  rule: Rule,
  options: Options
): TypeExpr {
  const refs = refsInRule(rule);
  const baseMembers: ObjectLiteralTypeMember[] = [
    { name: "type", type: tsTypeString(capitalize(ruleName)) },
    { name: "text", type: tsTypeName("string") },
    { name: "span", type: tsTypeName("Span") },
  ];

  if (rule.type === "Choice") {
    return refs.length === 0
      ? { type: "ObjectLiteralType", members: baseMembers }
      : tsUnionType(
          refs.map((ref) => {
            const inner = tsTypeName(
              typeName(ref.ruleName, options.typePrefix)
            );
            return ref.origin.repeated ? tsArrayType(inner) : inner;
          })
        );
  }

  const ruleMembers: ObjectLiteralTypeMember[] = refs
    .filter((ref) => !options.ignoreRules.has(ref.ruleName))
    .map((ref) => {
      const inner = tsTypeName(typeName(ref.ruleName, options.typePrefix));
      return {
        name: prefixToAvoidReserved(
          ref.captureName ? ref.captureName : ref.ruleName
        ),
        type: ref.origin.repeated
          ? tsArrayType(inner)
          : ref.origin.inChoice
          ? tsOrNull(inner)
          : inner,
      };
    });

  return {
    type: "ObjectLiteralType",
    members: [...baseMembers, ...ruleMembers],
  };
}

function generateGrammarConst(grammar: Grammar): string {
  return `export const GRAMMAR: Grammar = ${JSON.stringify(grammar, null, 2)}`;
}

function generateEntryPoints(grammar: Grammar, options: Options): string[] {
  return mapObjToList(
    filterObj(grammar, (ruleName) => !options.ignoreRules.has(ruleName)),
    (ruleName, rule) =>
      [
        `export function parse${typeName(
          ruleName,
          ""
        )}(input: string): [${typeName(
          ruleName,
          options.typePrefix
        )}, ParseError[]] {`,
        `  const traceTree = parserlib.parse(GRAMMAR, "${ruleName}", input)`,
        // TODO: problematic if there's a rule called RuleTree
        `  const [ruleTree, errors] = extractRuleTree(traceTree)`,
        `  const extracted = ${extractorName(ruleName)}(input, ruleTree)`,
        `  return [extracted, errors]`,
        `}`,
      ].join("\n")
  );
}

function typeName(ruleName: string, prefix: string) {
  return `${prefix}${capitalize(ruleName)}`;
}

function extractorName(ruleName: string) {
  // TODO: make camelCase
  return `extract${capitalize(ruleName)}`;
}

const RESERVED = new Set(["type", "text", "span"]);

function prefixToAvoidReserved(name: string): string {
  if (RESERVED.has(name)) {
    return `_${name}`;
  }
  return name;
}
