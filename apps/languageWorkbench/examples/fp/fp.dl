scope.Scope{id: I, label: I} :-
  ast.expr{id: I}.

scope.Defn{scopeID: I, span: S, name: N, kind: "var"} :-
  ast.expr{id: I} &
  ast.letExpr{id: LetExprID, parentID: I} &
  ast.ident{parentID: LetExprID, text: N, span: S}.

scope.Var{scopeID: I, name: N, span: S, kind: "var"} :-
  ast.expr{id: I} &
  ast.varExpr{parentID: I, text: N, span: S} |
  ast.expr{id: I} &
  ast.funcCall{id: FuncCallID, parentID: I} &
  ast.varExpr{parentID: FuncCallID, text: N, span: S}.

scope.Parent{childID: ChildID, parentID: ParentID} :-
  ast.expr{id: ParentID} &
  astInternal.node{parentID: ParentID, id: IntermediateID} &
  ast.expr{id: ChildID, parentID: IntermediateID}.

scope.Placeholder{scopeID: I, span: S, kind: "var"} :-
  ast.expr{id: I} &
  ast.placeholder{parentID: I, span: S}.

hl.mapping{rule: "intLit", type: "int"}.
hl.mapping{rule: "stringLit", type: "string"}.
hl.mapping{rule: "bool", type: "bool"}.
hl.mapping{rule: "ident", type: "ident"}.
hl.mapping{rule: "letKW", type: "keyword"}.
hl.mapping{rule: "inKW", type: "keyword"}.

.table lang.Builtin

ast.RootExpr{id: 0}.

tc.Type{id: I, type: T} :-
  tc.typeS{id: I, type: T} |
  tc.typeI{id: I, type: T} |
  tc.typeLambda{id: I, type: T} |
  tc.typeFC{id: I, type: T} |
  tc.typeLet{id: I, type: T} |
  tc.typeVar{id: I, type: T} |
  tc.typePlaceholder{id: I, type: T}.

tc.typeS{id: I, type: "string"} :-
  ast.stringLit{id: I}.
tc.typeI{id: I, type: "int"} :-
  ast.intLit{id: I}.
tc.typeFC{id: I, type: T} :-
  ast.funcCall{id: I, funcID: FID, argID: AID} &
  tc.Type{id: FID, type: tapp{from: F, to: T}} &
  tc.Type{id: AID, type: F}.
tc.typeLet{id: I, type: T} :-
  ast.letBodyExpr{letID: I, bodyID: BID} &
  tc.Type{id: BID, type: T}.
tc.typeVar{id: I, type: T} :-
  ast.varExpr{id: I, name: N} &
  tc.ScopeItem{id: I, name: N, type: T}.
# TODO: get this to work for multiple parameters...
tc.typeLambda{id: I, type: tapp{from: F, to: R}} :-
  ast.lambda{id: I, retType: R, body: B} &
  ast.lambdaParam{lambdaID: I, ty: F} &
  tc.Type{id: B, type: R}.
tc.typePlaceholder{id: I, type: "unknown"} :-
  ast.Placeholder{id: I}.

tc.ScopeItem{id: I, name: N, type: T, location: L} :-
  tc.scopeBuiltin{id: I, name: N, type: T, location: L} |
  tc.scopeLet{id: I, name: N, type: T, location: L} |
  tc.scopeLambda{id: I, name: N, type: T, location: L} |
  tc.parentScope{id: I, parentID: P} & tc.ScopeItem{id: P, name: N, type: T, location: L}.

tc.scopeBuiltin{id: I, name: N, type: T, location: "builtin"} :-
  ast.RootExpr{id: I} &
  lang.Builtin{name: N, type: T}.
tc.scopeLet{id: I, name: N, type: T, location: S} :-
  ast.letBodyExpr{letID: L, bodyID: I} &
  ast.letBindingExpr{letID: L, bindingID: B} &
  ast.letVar{letID: L, name: N, span: S} &
  tc.Type{id: B, type: T}.
tc.scopeLambda{id: I, name: N, type: T, location: L} :-
  ast.lambda{body: I, id: LID} &
  ast.lambdaParam{lambdaID: LID, name: N, ty: T, location: L}.

tc.parentScope{id: I, parentID: P} :-
  ast.letBindingExpr{letID: P, bindingID: I} |
  ast.letBodyExpr{letID: P, bodyID: I}.
  # ast.funcCallArg{callID: C, argID: I} |
  # ast.funcCallFunc{callID: C, funcID: F} |
  # ast.lambda{body: I, id: P}.

# parents
ast.letBindingExpr{letID: L, bindingID: D} :-
  ast.letExpr{letID: L} &
  ast.inKW{id: IN, parentID: L} &
  astInternal.next{prev: WS, next: IN} &
  astInternal.next{prev: D, next: WS}.
ast.letBodyExpr{letID: L, bodyID: I} :-
  ast.letExpr{letID: L} &
  ast.inKW{id: IN, parentID: L} &
  astInternal.next{prev: IN, next: WS} &
  astInternal.next{prev: WS, next: I}.
ast.letVar{letID: L, name: N, span: S} :-
  ast.letExpr{id: L} &
  ast.ident{parentID: L, text: N, span: S}.
# ast.funcCallArg{callID: C, argID: I} :-
#   XXX.
# ast.funcCallFunc{callID: C, funcID: F} :-
#   XXX.
# ast.lambdaBody{lambdaID: L, bodyID: B} :-
#   XXX.
