# === scenario ===

.table source
.table sink
.table battery
.table connection
.table internal.visualization

source{id: 1, supply: 10, x: 10, y: 20}.
source{id: 4, supply: 15, x: 200, y: 20}.
battery{id: 2, capacity: 100, initialLevel: 50, x: 60, y: 120}.
sink{id: 3, demand: 15, x: 60, y: 300}.
connection{from: 1, to: 2}.
connection{from: 2, to: 3}.
connection{from: 4, to: 2}.

# === rules ===

node{id: I, label: L, x: X, y: Y} :-
  nodeSource{id: I, label: L, x: X, y: Y} |
  nodeSink{id: I, label: L, x: X, y: Y} |
  nodeBattery{id: I, label: L, x: X, y: Y}.

nodeSource{id: I, label: source{id: I, supply: S}, x: X, y: Y} :-
  source{id: I, supply: S, x: X, y: Y}.
nodeSink{id: I, label: sink{id: I, demand: S}, x: X, y: Y} :-
  sink{id: I, demand: S, x: X, y: Y}.
nodeBattery{id: I, label: battery{id: I, capacity: S, initialLevel: IL}, x: X, y: Y} :-
  battery{id: I, capacity: S, initialLevel: IL, x: X, y: Y}.

current{id: I, time: T, level: L} :-
  currentAtSource{id: I, time: T, level: L} |
  currentAtSink{id: I, time: T, level: L}.

currentAtSource{id: I, time: T, level: ShiftedL} :-
  time{time: T} &
  source{id: I, supply: Size} &
  math.sin{a: T, res: Raw} &
  Raw * Size = C &
  30 + C = ShiftedL.
currentAtSink{id: I, time: T, level: ShiftedL} :-
  time{time: T} &
  T + 2 = ShiftedT &
  sink{id: I, demand: Size} &
  math.sin{a: ShiftedT, res: Raw} &
  Raw + Size = C &
  30 + C = ShiftedL.

batteryLevel{id: I, time: T, level: L} :-
  batteryLevelInitial{id: I, time: T, level: L} |
  batteryLevelStep{id: I, time: T, level: L}.
batteryLevelInitial{id: I, time: 1, level: L} :-
  battery{id: I, initialLevel: L}.
# # TODO: flexible discharge rate
# # TODO: look at demand
batteryLevelStep{id: I, time: T, level: NextLevel} :-
  battery{id: I, capacity: Capacity} &
  time{time: PrevT} &
  PrevT + 1 = T &
  batteryLevel{id: I, time: PrevT, level: PrevLevel} &
  batteryLevelDelta{id: I, time: T, delta: InputCurrent} &
  PrevLevel + InputCurrent = NotClamped &
  clamp{min: 0, max: Capacity, val: NotClamped, res: NextLevel}.

batteryLevelDelta{id: B, time: T, delta: Delta} :-
  batteryInputCurrent{id: B, time: T, current: Input} &
  batteryOutputCurrent{id: B, time: T, current: PosOutput} &
  invert{a: PosOutput, res: Output} &
  Input + Output = Delta.
batteryInputCurrentFrom{id: B, time: T, current: L, from: S} :-
  time{time: T} &
  battery{id: B} &
  source{id: S} &
  connection{from: S, to: B} &
  currentAtSource{id: S, time: T, level: L}.
batteryInputCurrent{id: B, time: T, current: C} :-
  sum[B, T, C: batteryInputCurrentFrom{id: B, time: T, current: C}].
batteryOutputCurrent{id: B, time: T, current: L} :-
  time{time: T} &
  battery{id: B} &
  sink{id: S} &
  connection{from: B, to: S} &
  currentAtSink{id: S, time: T, level: L}.

time{time: T} :-
  range{from: 1, to: 30, val: T}.

# === visualization ===

internal.visualization{
  name: "Current over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "level", type: "quantitative"},
      color: mapping{field: "id"}
    },
    query: current{}
  }
}.

internal.visualization{
  name: "Battery Level",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "level", type: "quantitative"},
      color: mapping{field: "id"}
    },
    query: batteryLevel{}
  }
}.

tableRow{label: L} :-
  node{label: L} |
  connRow{label: L}.
connRow{label: connection{from: F, to: T}} :-
  connection{from: F, to: T}.

internal.visualization{
  name: "Sources",
  spec: tableEditor{
    query: tableRow{},
    new: [
      source{id: ID, supply: 10},
      sink{id: ID, demand: 10},
      battery{id: ID, capacity: 100, initialLevel: 50},
      connection{from: ID1, to: ID2}
    ]
  }
}.

testNode{id: 1, x: 10, y: 20, label: "foo"}.
testNode{id: 2, x: 10, y: 100, label: "bar"}.
testNode{id: 3, x: 10, y: 200, label: "baz"}.
testEdge{id: "1-2", from: 1, to: 2}.
testEdge{id: "2-3", from: 2, to: 3}.

internal.visualization{
  name: "Editor",
  spec: dagEditor{
    nodes: node{},
    edges: connection{},
    newEdge: connection{},
    newNodes: [
      source{supply: 10},
      sink{demand: 15},
      battery{capacity: 100, initialLevel: 50},
    ],
  },
}.
