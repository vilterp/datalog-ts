instr{idx: 0, op: store{var: "x", val: 0}}.
instr{idx: 1, op: increment{var: "x"}}.
instr{idx: 2, op: store{var: "y", val: lt{var: "x", val: 5}}}.
instr{idx: 3, op: fork{goto: 5}}.
instr{idx: 4, op: conditionalGoto{dest: 1, var: "y"}}.
instr{idx: 5, op: increment{var: "x"}}.
instr{idx: 6, op: increment{var: "x"}}.
instr{idx: 7, op: increment{var: "x"}}.

time{time: T} :-
  range{from: 1, to: 10, val: T}.

# state.threadState{thread: TH, time: T, state: S} :-
#   state.threadState.init{thread: TH, time: T, state: S} |
#   state.threadState{thread: TH, time: PrevT, state: PrevS} &
#   state.threadState.step{thread: TH, time: T, state: S} &
#   T = PrevT + 1.

# init
state.threadState.init{thread: 1, time: 0, state: "Running"}.

# === Program Counter ===

state.ProgramCounter{thread: TH, time: T, counter: C} :-
  state.programCounter.init{thread: TH, time: T, counter: C} |
  state.programCounter.store{thread: TH, time: T, counter: C} |
  state.programCounter.increment{thread: TH, time: T, counter: C} |
  state.programCounter.fork{thread: TH, time: T, counter: C}.
  # state.programCounter.condGoto{thread: TH, time: T, counter: C}.

state.programCounter.init{thread: 1, time: 0, counter: 0}.

state.programCounter.store{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: store{}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.
state.programCounter.increment{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: increment{}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.

# fork
state.programCounter.fork{thread: TH, time: T, counter: C} :-
  state.programCounter.fork.orig{thread: TH, time: T, counter: C} |
  state.programCounter.fork.new{thread: TH, time: T, counter: C}.
state.programCounter.fork.orig{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: fork{goto: ForkC}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.
state.programCounter.fork.new{thread: TH, time: T, counter: ForkC} :-
  time{time: T} &
  instr{idx: PrevC, op: fork{goto: ForkC}} &
  T = PrevT + 1 &
  state.ProgramCounter{thread: PrevTH, time: PrevT, counter: PrevC} &
  TH = PrevTH + 100.

# goto
state.programCounter.condGoto{thread: TH, time: T, counter: C} :-
  state.programCounter.condGoto.yes{thread: TH, time: T, counter: C} |
  state.programCounter.condGoto.no{thread: TH, time: T, counter: C}.

state.programCounter.condGoto.yes{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: conditionalGoto{dest: C, var: Var}} &
  T = PrevT + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC} &
  state.Var{thread: TH, time: PrevT, var: Var, value: true}.
state.programCounter.condGoto.no{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: conditionalGoto{var: Var}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC} &
  state.Var{thread: TH, time: PrevT, var: Var, value: false}.

# === Var ===

state.Var{thread: TH, time: T, var: Var, value: Val} :-
  state.var.store{thread: TH, time: T, var: Var, value: Val} |
  state.var.increment{thread: TH, time: T, var: Var, value: Val} |
  state.var.stay{thread: TH, time: T, var: Var, value: Val}.

state.var.store{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: Expr}} &
  eval{expr: Expr, thread: TH, time: PrevT, value: Val} &
  T = PrevT + 1.
state.var.increment{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: increment{var: Var}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  Val = PrevVal + 1.

# == stay
state.var.stay{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.increment{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.fork{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.condGoto{thread: TH, time: T, var: Var, value: PrevVal}.
# store & increment
state.var.stay.increment{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: store{var: OtherVar}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  OtherVar != Var.
state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: increment{var: OtherVar}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  OtherVar != Var.
# fork
state.var.stay.fork{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.fork.orig{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.fork.new{thread: TH, time: T, var: Var, value: PrevVal}.
state.var.stay.fork.orig{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: fork{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.
state.var.stay.fork.new{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: NewTH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: fork{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  NewTH = TH + 100.
# condGoto
state.var.stay.condGoto{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: conditionalGoto{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.

# === Eval ===

# Expressions

eval{thread: TH, time: T, expr: Expr, value: Value} :-
  eval.Lt{thread: TH, time: T, expr: Expr, value: Value} |
  eval.IntLit{expr: Expr, value: Value}.

eval.Lt{thread: TH, time: T, expr: Expr, value: V} :-
  eval.Lt.True{thread: TH, time: T, expr: Expr, value: V} |
  eval.Lt.False{thread: TH, time: T, expr: Expr, value: V}.
# this pattern is so wonky lol
eval.Lt.True{thread: TH, time: T, expr: lt{var: Var, val: LiteralVal}, value: true} :-
  state.Var{thread: TH, time: T, var: Var, value: VarVal} &
  VarVal < LiteralVal.
eval.Lt.False{thread: TH, time: T, expr: lt{var: Var, val: LiteralVal}, value: false} :-
  state.Var{thread: TH, time: T, var: Var, value: VarVal} &
  VarVal >= LiteralVal.
eval.IntLit{expr: Expr, value: Value} :-
  base.int{a: Expr} &
  Expr = Value.

# === Viz ===

internal.visualization{
  name: "Program Counter over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "counter", type: "quantitative"},
      color: mapping{field: "thread"}
    },
    query: state.ProgramCounter{}
  }
}.

# TODO: another encoding channel for thread
internal.visualization{
  name: "Variables Over over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "value", type: "quantitative"},
      color: mapping{field: "var"}
    },
    query: state.Var{}
  }
}.
