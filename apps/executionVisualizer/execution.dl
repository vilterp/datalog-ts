.table instr
.table maxTime
.table expr.funcCall
.table expr.funcArg
.table expr.intLit
.table expr.var

# time

maxTime{time: 30}.

time{time: T} :-
  maxTime{time: MaxT} &
  range{from: 0, to: MaxT, val: T}.

# === Program Counter ===

state.ProgramCounter{thread: TH, time: T, counter: C} :-
  state.programCounter.init{thread: TH, time: T, counter: C} |
  state.programCounter.store{thread: TH, time: T, counter: C} |
  state.programCounter.fork{thread: TH, time: T, counter: C} |
  state.programCounter.goto{thread: TH, time: T, counter: C} |
  state.programCounter.gotoIf{thread: TH, time: T, counter: C}.

.table state.programCounter.init

# TODO: only proceed if we're storing a primitive result or a literal
state.programCounter.store{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: store{}} &
  T = PrevT + 1 &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.

# fork
state.programCounter.fork{thread: TH, time: T, counter: C} :-
  state.programCounter.fork.orig{thread: TH, time: T, counter: C} |
  state.programCounter.fork.new{thread: TH, time: T, counter: C}.
state.programCounter.fork.orig{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: store{val: call{fun: "fork"}}} &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC} &
  T = PrevT + 1 &
  C = PrevC + 1.
state.programCounter.fork.new{
  thread: TH,
  origThread: PrevTH,
  time: T,
  counter: C,
} :-
  time{time: T} &
  instr{idx: PrevC, op: store{val: call{fun: "fork"}}} &
  state.ProgramCounter{thread: PrevTH, time: PrevT, counter: PrevC} &
  T = PrevT + 1 &
  ShiftedT = T + 100 &
  TH = PrevTH + ShiftedT &
  C = PrevC + 1.

# condGoto
state.programCounter.gotoIf{thread: TH, time: T, counter: C} :-
  state.programCounter.gotoIf.yes{thread: TH, time: T, counter: C} |
  state.programCounter.gotoIf.no{thread: TH, time: T, counter: C}.
state.programCounter.gotoIf.yes{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: gotoIf{dest: C, cond: Var}} &
  T = PrevT + 1 &
  state.Var{thread: TH, time: PrevT, var: Var, value: true} &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.
state.programCounter.gotoIf.no{thread: TH, time: T, counter: C} :-
  time{time: T} &
  instr{idx: PrevC, op: gotoIf{cond: Var}} &
  T = PrevT + 1 &
  state.Var{thread: TH, time: PrevT, var: Var, value: false} &
  C = PrevC + 1 &
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC}.
# goto
state.programCounter.goto{thread: TH, time: T, counter: C} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: PrevC} &
  T = PrevT + 1 &
  instr{idx: PrevC, op: goto{dest: C}}.

# === Var ===

state.Var{thread: TH, time: T, var: Var, value: Val} :-
  state.var.storeInt{thread: TH, time: T, var: Var, value: Val} |
  # TODO: storeString
  state.var.storeCallIncr{thread: TH, time: T, var: Var, value: Val} |
  state.var.storeCallLT{thread: TH, time: T, var: Var, value: Val} |
  state.var.storeCallFork{thread: TH, time: T, var: Var, value: Val} |
  state.var.stay{thread: TH, time: T, var: Var, value: Val}.

state.var.storeInt{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: Val}} &
  base.int{a: Val} &
  T = PrevT + 1.
state.var.storeCallIncr{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.incr", args: [ArgVar]}}} &
  state.Var{thread: TH, time: PrevT, var: ArgVar, value: ArgVal} &
  Val = ArgVal + 1 &
  T = PrevT + 1.
state.var.storeCallLT{thread: TH, time: T, var: Var, value: Val} :-
  state.var.storeCallLT.yes{thread: TH, time: T, var: Var, value: Val} |
  state.var.storeCallLT.no{thread: TH, time: T, var: Var, value: Val}.
state.var.storeCallLT.yes{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.lt", args: [Arg1Var, Arg2Var]}}} &
  state.Var{thread: TH, time: PrevT, var: Arg1Var, value: Arg1Val} &
  state.Var{thread: TH, time: PrevT, var: Arg2Var, value: Arg2Val} &
  Arg1Val < Arg2Val &
  Val = true &
  T = PrevT + 1.
state.var.storeCallLT.no{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: primitive{fun: "prim.lt", args: [Arg1Var, Arg2Var]}}} &
  state.Var{thread: TH, time: PrevT, var: Arg1Var, value: Arg1Val} &
  state.Var{thread: TH, time: PrevT, var: Arg2Var, value: Arg2Val} &
  Arg1Val >= Arg2Val &
  Val = false &
  T = PrevT + 1.
state.var.storeCallFork{thread: TH, time: T, var: Var, value: Val} :-
  state.var.storeCallFork.new{thread: TH, time: T, var: Var, value: Val} |
  state.var.storeCallFork.orig{thread: TH, time: T, var: Var, value: Val}.
state.var.storeCallFork.new{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: PrevTH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: call{fun: "fork"}}} &
  T = PrevT + 1 &
  ShiftedT = T + 100 &
  TH = PrevTH + ShiftedT &
  Val = true.
state.var.storeCallFork.orig{thread: TH, time: T, var: Var, value: Val} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  instr{idx: C, op: store{var: Var, val: call{fun: "fork"}}} &
  Val = false &
  T = PrevT + 1.

# == stay ==
# propagate forward in time the values of variables that
# aren't being changed at this timestep
state.var.stay{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.goto{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.gotoIf{thread: TH, time: T, var: Var, value: PrevVal}.
# store & increment
state.var.stay.store{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: store{var: OtherVar}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal} &
  OtherVar != Var.
# fork
state.var.stay.fork{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.var.stay.fork.orig{thread: TH, time: T, var: Var, value: PrevVal} |
  state.var.stay.fork.new{thread: TH, time: T, var: Var, value: PrevVal}.
state.var.stay.fork.orig{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: store{val: call{fun: "fork"}}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.
state.var.stay.fork.new{thread: NewTH, time: T, var: Var, value: Val} :-
  state.programCounter.fork.new{origThread: OrigTH, thread: NewTH, time: T} &
  T = PrevT + 1 &
  state.Var{thread: OrigTH, time: PrevT, var: Var, value: Val}.
# goto
state.var.stay.goto{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: goto{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.
# gotoIf
state.var.stay.gotoIf{thread: TH, time: T, var: Var, value: PrevVal} :-
  state.ProgramCounter{thread: TH, time: PrevT, counter: C} &
  T = PrevT + 1 &
  instr{idx: C, op: gotoIf{}} &
  state.Var{thread: TH, time: PrevT, var: Var, value: PrevVal}.

# === Viz ===

.table internal.visualization

# internal.visualization{
#   name: "Time Ticker",
#   spec: ticker{},
# }.

internal.visualization{
  name: "Program Counter over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "counter", type: "quantitative"},
      color: mapping{field: "thread"}
    },
    query: state.ProgramCounter{}
  }
}.

viz.threadVar{time: T, tv: [TH, V], value: Val} :-
  state.Var{thread: TH, time: T, var: V, value: Val}.

# TODO: another encoding channel for thread
internal.visualization{
  name: "Variables Over over Time",
  spec: vegalite{
    mark: "line",
    encoding: encoding{
      x: mapping{field: "time", type: "quantitative"},
      y: mapping{field: "value", type: "quantitative"},
      color: mapping{field: "tv"}
    },
    query: viz.threadVar{}
  }
}.

viz.message{fromTick: FromTick, toTick: ToTick} :-
  viz.spawnMessage{fromTick: FromTick, toTick: ToTick} |
  viz.continueMessage{fromTick: FromTick, toTick: ToTick}.
viz.spawnMessage{
  fromTick: tick{time: FromT, place: FromTH},
  toTick: tick{time: ToT, place: ToTH}
} :-
  state.programCounter.fork.new{thread: ToTH, time: ToT, origThread: FromTH} &
  ToT = FromT + 1.
viz.continueMessage{
  fromTick: tick{time: PrevT, place: TH},
  toTick: tick{time: T, place: TH}
} :-
  state.ProgramCounter{thread: TH, time: PrevT} &
  state.ProgramCounter{thread: TH, time: T} &
  PrevT = T + 1.

internal.visualization{
  name: "Spawning Sequence",
  spec: sequence{
    actors: state.ProgramCounter{thread: ID},
    messages: viz.message{fromTick: FromTick, toTick: ToTick},
  },
}.

# insertion

state.programCounter.init{thread: 1, time: 1, counter: 0}.
